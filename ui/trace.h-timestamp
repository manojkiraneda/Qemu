/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_UI_GENERATED_TRACERS_H
#define TRACE_UI_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_CONSOLE_GFX_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_CSI_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_UNHANDLED_EVENT;
extern TraceEvent _TRACE_CONSOLE_TXT_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_SELECT_EVENT;
extern TraceEvent _TRACE_CONSOLE_REFRESH_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_FROM_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_FREE_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_REGISTER_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_EVENT;
extern TraceEvent _TRACE_PPM_SAVE_EVENT;
extern TraceEvent _TRACE_GD_SWITCH_EVENT;
extern TraceEvent _TRACE_GD_UPDATE_EVENT;
extern TraceEvent _TRACE_GD_KEY_EVENT_EVENT;
extern TraceEvent _TRACE_GD_GRAB_EVENT;
extern TraceEvent _TRACE_GD_UNGRAB_EVENT;
extern TraceEvent _TRACE_VNC_KEY_GUEST_LEDS_EVENT;
extern TraceEvent _TRACE_VNC_KEY_MAP_INIT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_EXT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_MAP_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_NUMLOCK_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_CAPSLOCK_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_NUMBER_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_QCODE_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_BTN_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_REL_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_ABS_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_SYNC_EVENT;
extern TraceEvent _TRACE_INPUT_MOUSE_MODE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_ADD_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DEL_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_WAKEUP_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_UPDATE_EVENT;
extern uint16_t _TRACE_CONSOLE_GFX_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_CSI_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_UNHANDLED_DSTATE;
extern uint16_t _TRACE_CONSOLE_TXT_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_SELECT_DSTATE;
extern uint16_t _TRACE_CONSOLE_REFRESH_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_FROM_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_FREE_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_REGISTER_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_DSTATE;
extern uint16_t _TRACE_PPM_SAVE_DSTATE;
extern uint16_t _TRACE_GD_SWITCH_DSTATE;
extern uint16_t _TRACE_GD_UPDATE_DSTATE;
extern uint16_t _TRACE_GD_KEY_EVENT_DSTATE;
extern uint16_t _TRACE_GD_GRAB_DSTATE;
extern uint16_t _TRACE_GD_UNGRAB_DSTATE;
extern uint16_t _TRACE_VNC_KEY_GUEST_LEDS_DSTATE;
extern uint16_t _TRACE_VNC_KEY_MAP_INIT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_EXT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_MAP_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_NUMLOCK_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_CAPSLOCK_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_NUMBER_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_QCODE_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_BTN_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_REL_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_ABS_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_SYNC_DSTATE;
extern uint16_t _TRACE_INPUT_MOUSE_MODE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_ADD_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DEL_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_WAKEUP_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_UPDATE_DSTATE;
#define TRACE_CONSOLE_GFX_NEW_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_CSI_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_ENABLED 1
#define TRACE_CONSOLE_TXT_NEW_ENABLED 1
#define TRACE_CONSOLE_SELECT_ENABLED 1
#define TRACE_CONSOLE_REFRESH_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_FROM_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_ENABLED 1
#define TRACE_DISPLAYSURFACE_FREE_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_REGISTER_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_ENABLED 1
#define TRACE_PPM_SAVE_ENABLED 1
#define TRACE_GD_SWITCH_ENABLED 1
#define TRACE_GD_UPDATE_ENABLED 1
#define TRACE_GD_KEY_EVENT_ENABLED 1
#define TRACE_GD_GRAB_ENABLED 1
#define TRACE_GD_UNGRAB_ENABLED 1
#define TRACE_VNC_KEY_GUEST_LEDS_ENABLED 1
#define TRACE_VNC_KEY_MAP_INIT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_EXT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_MAP_ENABLED 1
#define TRACE_VNC_KEY_SYNC_NUMLOCK_ENABLED 1
#define TRACE_VNC_KEY_SYNC_CAPSLOCK_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_NUMBER_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_QCODE_ENABLED 1
#define TRACE_INPUT_EVENT_BTN_ENABLED 1
#define TRACE_INPUT_EVENT_REL_ENABLED 1
#define TRACE_INPUT_EVENT_ABS_ENABLED 1
#define TRACE_INPUT_EVENT_SYNC_ENABLED 1
#define TRACE_INPUT_MOUSE_MODE_ENABLED 1
#define TRACE_QEMU_SPICE_ADD_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_DEL_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_WAKEUP_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_UPDATE_ENABLED 1
#include "qemu/log.h"


static inline void trace_console_gfx_new(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_GFX_NEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_gfx_new " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_PUTCHAR_CSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_putchar_csi " "escape sequence CSI%d;%d%c, %d parameters" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , esc_param0, esc_param1, ch, nb_esc_params);
        }
    }
}

static inline void trace_console_putchar_unhandled(int ch)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_PUTCHAR_UNHANDLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_putchar_unhandled " "unhandled escape character '%c'" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ch);
        }
    }
}

static inline void trace_console_txt_new(int w, int h)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_TXT_NEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_txt_new " "%dx%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , w, h);
        }
    }
}

static inline void trace_console_select(int nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_SELECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_select " "%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nr);
        }
    }
}

static inline void trace_console_refresh(int interval)
{
    if (true) {
        if (trace_event_get_state(TRACE_CONSOLE_REFRESH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:console_refresh " "interval %d ms" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , interval);
        }
    }
}

static inline void trace_displaysurface_create(void * display_surface, int w, int h)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaysurface_create " "surface=%p, %dx%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , display_surface, w, h);
        }
    }
}

static inline void trace_displaysurface_create_from(void * display_surface, int w, int h, uint32_t format)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE_FROM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaysurface_create_from " "surface=%p, %dx%d, format 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , display_surface, w, h, format);
        }
    }
}

static inline void trace_displaysurface_create_pixman(void * display_surface)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE_PIXMAN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaysurface_create_pixman " "surface=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , display_surface);
        }
    }
}

static inline void trace_displaysurface_free(void * display_surface)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYSURFACE_FREE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaysurface_free " "surface=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , display_surface);
        }
    }
}

static inline void trace_displaychangelistener_register(void * dcl, const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_REGISTER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaychangelistener_register " "%p [ %s ]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dcl, name);
        }
    }
}

static inline void trace_displaychangelistener_unregister(void * dcl, const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_UNREGISTER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:displaychangelistener_unregister " "%p [ %s ]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dcl, name);
        }
    }
}

static inline void trace_ppm_save(const char * filename, void * display_surface)
{
    if (true) {
        if (trace_event_get_state(TRACE_PPM_SAVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ppm_save " "%s surface=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , filename, display_surface);
        }
    }
}

static inline void trace_gd_switch(const char * tab, int width, int height)
{
    if (true) {
        if (trace_event_get_state(TRACE_GD_SWITCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:gd_switch " "tab=%s, width=%d, height=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tab, width, height);
        }
    }
}

static inline void trace_gd_update(const char * tab, int x, int y, int w, int h)
{
    if (true) {
        if (trace_event_get_state(TRACE_GD_UPDATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:gd_update " "tab=%s, x=%d, y=%d, w=%d, h=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tab, x, y, w, h);
        }
    }
}

static inline void trace_gd_key_event(const char * tab, int gdk_keycode, int qemu_keycode, const char * action)
{
    if (true) {
        if (trace_event_get_state(TRACE_GD_KEY_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:gd_key_event " "tab=%s, translated GDK keycode %d to QEMU keycode %d (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tab, gdk_keycode, qemu_keycode, action);
        }
    }
}

static inline void trace_gd_grab(const char * tab, const char * device, const char * reason)
{
    if (true) {
        if (trace_event_get_state(TRACE_GD_GRAB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:gd_grab " "tab=%s, dev=%s, reason=%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tab, device, reason);
        }
    }
}

static inline void trace_gd_ungrab(const char * tab, const char * device)
{
    if (true) {
        if (trace_event_get_state(TRACE_GD_UNGRAB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:gd_ungrab " "tab=%s, dev=%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , tab, device);
        }
    }
}

static inline void trace_vnc_key_guest_leds(bool caps, bool num, bool scroll)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_GUEST_LEDS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_guest_leds " "caps %d, num %d, scroll %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , caps, num, scroll);
        }
    }
}

static inline void trace_vnc_key_map_init(const char * layout)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_MAP_INIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_map_init " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , layout);
        }
    }
}

static inline void trace_vnc_key_event_ext(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_EVENT_EXT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_event_ext " "down %d, sym 0x%x, keycode 0x%x [%s]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , down, sym, keycode, name);
        }
    }
}

static inline void trace_vnc_key_event_map(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_EVENT_MAP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_event_map " "down %d, sym 0x%x -> keycode 0x%x [%s]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , down, sym, keycode, name);
        }
    }
}

static inline void trace_vnc_key_sync_numlock(bool on)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_SYNC_NUMLOCK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_sync_numlock " "%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , on);
        }
    }
}

static inline void trace_vnc_key_sync_capslock(bool on)
{
    if (true) {
        if (trace_event_get_state(TRACE_VNC_KEY_SYNC_CAPSLOCK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vnc_key_sync_capslock " "%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , on);
        }
    }
}

static inline void trace_input_event_key_number(int conidx, int number, const char * qcode, bool down)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_KEY_NUMBER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_key_number " "con %d, key number 0x%x [%s], down %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , conidx, number, qcode, down);
        }
    }
}

static inline void trace_input_event_key_qcode(int conidx, const char * qcode, bool down)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_KEY_QCODE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_key_qcode " "con %d, key qcode %s, down %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , conidx, qcode, down);
        }
    }
}

static inline void trace_input_event_btn(int conidx, const char * btn, bool down)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_BTN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_btn " "con %d, button %s, down %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , conidx, btn, down);
        }
    }
}

static inline void trace_input_event_rel(int conidx, const char * axis, int value)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_REL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_rel " "con %d, axis %s, value %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , conidx, axis, value);
        }
    }
}

static inline void trace_input_event_abs(int conidx, const char * axis, int value)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_ABS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_abs " "con %d, axis %s, value 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , conidx, axis, value);
        }
    }
}

static inline void trace_input_event_sync(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_EVENT_SYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_event_sync " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_input_mouse_mode(int absolute)
{
    if (true) {
        if (trace_event_get_state(TRACE_INPUT_MOUSE_MODE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:input_mouse_mode " "absolute %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , absolute);
        }
    }
}

static inline void trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_ADD_MEMSLOT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_add_memslot " "%d %u: host virt 0x%lx - 0x%lx async=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qid, slot_id, virt_start, virt_end, async);
        }
    }
}

static inline void trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_DEL_MEMSLOT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_del_memslot " "%d gid=%u sid=%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qid, gid, slot_id);
        }
    }
}

static inline void trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_create_primary_surface " "%d sid=%u surface=%p async=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qid, sid, surface, async);
        }
    }
}

static inline void trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_destroy_primary_surface " "%d sid=%u async=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qid, sid, async);
        }
    }
}

static inline void trace_qemu_spice_wakeup(uint32_t qid)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_WAKEUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_wakeup " "%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qid);
        }
    }
}

static inline void trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    if (true) {
        if (trace_event_get_state(TRACE_QEMU_SPICE_CREATE_UPDATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qemu_spice_create_update " "lr %d -> %d,  tb -> %d -> %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , left, right, top, bottom);
        }
    }
}
#endif /* TRACE_UI_GENERATED_TRACERS_H */
