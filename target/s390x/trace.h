/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_TARGET_S390X_GENERATED_TRACERS_H
#define TRACE_TARGET_S390X_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_GET_SKEYS_NONZERO_EVENT;
extern TraceEvent _TRACE_SET_SKEYS_NONZERO_EVENT;
extern TraceEvent _TRACE_IOINST_EVENT;
extern TraceEvent _TRACE_IOINST_SCH_ID_EVENT;
extern TraceEvent _TRACE_IOINST_CHP_ID_EVENT;
extern TraceEvent _TRACE_IOINST_CHSC_CMD_EVENT;
extern TraceEvent _TRACE_KVM_ENABLE_CMMA_EVENT;
extern TraceEvent _TRACE_KVM_CLEAR_CMMA_EVENT;
extern TraceEvent _TRACE_KVM_FAILED_CPU_STATE_SET_EVENT;
extern TraceEvent _TRACE_KVM_SIGP_FINISHED_EVENT;
extern TraceEvent _TRACE_CPU_SET_STATE_EVENT;
extern TraceEvent _TRACE_CPU_HALT_EVENT;
extern TraceEvent _TRACE_CPU_UNHALT_EVENT;
extern uint16_t _TRACE_GET_SKEYS_NONZERO_DSTATE;
extern uint16_t _TRACE_SET_SKEYS_NONZERO_DSTATE;
extern uint16_t _TRACE_IOINST_DSTATE;
extern uint16_t _TRACE_IOINST_SCH_ID_DSTATE;
extern uint16_t _TRACE_IOINST_CHP_ID_DSTATE;
extern uint16_t _TRACE_IOINST_CHSC_CMD_DSTATE;
extern uint16_t _TRACE_KVM_ENABLE_CMMA_DSTATE;
extern uint16_t _TRACE_KVM_CLEAR_CMMA_DSTATE;
extern uint16_t _TRACE_KVM_FAILED_CPU_STATE_SET_DSTATE;
extern uint16_t _TRACE_KVM_SIGP_FINISHED_DSTATE;
extern uint16_t _TRACE_CPU_SET_STATE_DSTATE;
extern uint16_t _TRACE_CPU_HALT_DSTATE;
extern uint16_t _TRACE_CPU_UNHALT_DSTATE;
#define TRACE_GET_SKEYS_NONZERO_ENABLED 1
#define TRACE_SET_SKEYS_NONZERO_ENABLED 1
#define TRACE_IOINST_ENABLED 1
#define TRACE_IOINST_SCH_ID_ENABLED 1
#define TRACE_IOINST_CHP_ID_ENABLED 1
#define TRACE_IOINST_CHSC_CMD_ENABLED 1
#define TRACE_KVM_ENABLE_CMMA_ENABLED 1
#define TRACE_KVM_CLEAR_CMMA_ENABLED 1
#define TRACE_KVM_FAILED_CPU_STATE_SET_ENABLED 1
#define TRACE_KVM_SIGP_FINISHED_ENABLED 1
#define TRACE_CPU_SET_STATE_ENABLED 1
#define TRACE_CPU_HALT_ENABLED 1
#define TRACE_CPU_UNHALT_ENABLED 1
#include "qemu/log.h"


static inline void trace_get_skeys_nonzero(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_GET_SKEYS_NONZERO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:get_skeys_nonzero " "SKEY: Call to get_skeys unexpectedly returned %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_set_skeys_nonzero(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_SET_SKEYS_NONZERO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:set_skeys_nonzero " "SKEY: Call to set_skeys unexpectedly returned %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_ioinst(const char * insn)
{
    if (true) {
        if (trace_event_get_state(TRACE_IOINST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ioinst " "IOINST: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , insn);
        }
    }
}

static inline void trace_ioinst_sch_id(const char * insn, int cssid, int ssid, int schid)
{
    if (true) {
        if (trace_event_get_state(TRACE_IOINST_SCH_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ioinst_sch_id " "IOINST: %s (%x.%x.%04x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , insn, cssid, ssid, schid);
        }
    }
}

static inline void trace_ioinst_chp_id(const char * insn, int cssid, int chpid)
{
    if (true) {
        if (trace_event_get_state(TRACE_IOINST_CHP_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ioinst_chp_id " "IOINST: %s (%x.%02x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , insn, cssid, chpid);
        }
    }
}

static inline void trace_ioinst_chsc_cmd(uint16_t cmd, uint16_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_IOINST_CHSC_CMD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ioinst_chsc_cmd " "IOINST: chsc command %04x, len %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cmd, len);
        }
    }
}

static inline void trace_kvm_enable_cmma(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_KVM_ENABLE_CMMA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:kvm_enable_cmma " "CMMA: enabling with result code %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_kvm_clear_cmma(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_KVM_CLEAR_CMMA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:kvm_clear_cmma " "CMMA: clearing with result code %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_kvm_failed_cpu_state_set(int cpu_index, uint8_t state, const char * msg)
{
    if (true) {
        if (trace_event_get_state(TRACE_KVM_FAILED_CPU_STATE_SET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:kvm_failed_cpu_state_set " "Warning: Unable to set cpu %d state %" PRIu8 " to KVM: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cpu_index, state, msg);
        }
    }
}

static inline void trace_kvm_sigp_finished(uint8_t order, int cpu_index, int dst_index, int cc)
{
    if (true) {
        if (trace_event_get_state(TRACE_KVM_SIGP_FINISHED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:kvm_sigp_finished " "SIGP: Finished order %u on cpu %d -> cpu %d with cc=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , order, cpu_index, dst_index, cc);
        }
    }
}

static inline void trace_cpu_set_state(int cpu_index, uint8_t state)
{
    if (true) {
        if (trace_event_get_state(TRACE_CPU_SET_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:cpu_set_state " "setting cpu %d state to %" PRIu8 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cpu_index, state);
        }
    }
}

static inline void trace_cpu_halt(int cpu_index)
{
    if (true) {
        if (trace_event_get_state(TRACE_CPU_HALT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:cpu_halt " "halting cpu %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cpu_index);
        }
    }
}

static inline void trace_cpu_unhalt(int cpu_index)
{
    if (true) {
        if (trace_event_get_state(TRACE_CPU_UNHALT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:cpu_unhalt " "unhalting cpu %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cpu_index);
        }
    }
}
#endif /* TRACE_TARGET_S390X_GENERATED_TRACERS_H */
