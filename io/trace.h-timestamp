/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_IO_GENERATED_TRACERS_H
#define TRACE_IO_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_QIO_TASK_NEW_EVENT;
extern TraceEvent _TRACE_QIO_TASK_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_START_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_RUN_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_EXIT_EVENT;
extern TraceEvent _TRACE_QIO_TASK_THREAD_RESULT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_NEW_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_NEW_FD_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_FILE_NEW_FD_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_FILE_NEW_PATH_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_NEW_SERVER_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_NEW_PID_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_ABORT_EVENT;
extern TraceEvent _TRACE_QIO_CHANNEL_COMMAND_WAIT_EVENT;
extern uint16_t _TRACE_QIO_TASK_NEW_DSTATE;
extern uint16_t _TRACE_QIO_TASK_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_START_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_RUN_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_EXIT_DSTATE;
extern uint16_t _TRACE_QIO_TASK_THREAD_RESULT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_NEW_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_NEW_FD_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_FILE_NEW_FD_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_FILE_NEW_PATH_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_NEW_SERVER_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_NEW_PID_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_ABORT_DSTATE;
extern uint16_t _TRACE_QIO_CHANNEL_COMMAND_WAIT_DSTATE;
#define TRACE_QIO_TASK_NEW_ENABLED 1
#define TRACE_QIO_TASK_COMPLETE_ENABLED 1
#define TRACE_QIO_TASK_THREAD_START_ENABLED 1
#define TRACE_QIO_TASK_THREAD_RUN_ENABLED 1
#define TRACE_QIO_TASK_THREAD_EXIT_ENABLED 1
#define TRACE_QIO_TASK_THREAD_RESULT_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_NEW_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_NEW_FD_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_FILE_NEW_FD_ENABLED 1
#define TRACE_QIO_CHANNEL_FILE_NEW_PATH_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_NEW_CLIENT_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_NEW_SERVER_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW_ENABLED 1
#define TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL_ENABLED 1
#define TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_NEW_PID_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_ABORT_ENABLED 1
#define TRACE_QIO_CHANNEL_COMMAND_WAIT_ENABLED 1
#include "qemu/log.h"


static inline void trace_qio_task_new(void * task, void * source, void * func, void * opaque)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_NEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_new " "Task new task=%p source=%p func=%p opaque=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task, source, func, opaque);
        }
    }
}

static inline void trace_qio_task_complete(void * task)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_complete " "Task complete task=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task);
        }
    }
}

static inline void trace_qio_task_thread_start(void * task, void * worker, void * opaque)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_THREAD_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_thread_start " "Task thread start task=%p worker=%p opaque=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task, worker, opaque);
        }
    }
}

static inline void trace_qio_task_thread_run(void * task)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_THREAD_RUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_thread_run " "Task thread run task=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task);
        }
    }
}

static inline void trace_qio_task_thread_exit(void * task)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_THREAD_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_thread_exit " "Task thread exit task=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task);
        }
    }
}

static inline void trace_qio_task_thread_result(void * task)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_TASK_THREAD_RESULT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_task_thread_result " "Task thread result task=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , task);
        }
    }
}

static inline void trace_qio_channel_socket_new(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_NEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_new " "Socket new ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_new_fd(void * ioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_NEW_FD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_new_fd " "Socket new ioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, fd);
        }
    }
}

static inline void trace_qio_channel_socket_connect_sync(void * ioc, void * addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_SYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_connect_sync " "Socket connect sync ioc=%p addr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, addr);
        }
    }
}

static inline void trace_qio_channel_socket_connect_async(void * ioc, void * addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_connect_async " "Socket connect async ioc=%p addr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, addr);
        }
    }
}

static inline void trace_qio_channel_socket_connect_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_connect_fail " "Socket connect fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_connect_complete(void * ioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_CONNECT_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_connect_complete " "Socket connect complete ioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, fd);
        }
    }
}

static inline void trace_qio_channel_socket_listen_sync(void * ioc, void * addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_SYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_listen_sync " "Socket listen sync ioc=%p addr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, addr);
        }
    }
}

static inline void trace_qio_channel_socket_listen_async(void * ioc, void * addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_listen_async " "Socket listen async ioc=%p addr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, addr);
        }
    }
}

static inline void trace_qio_channel_socket_listen_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_listen_fail " "Socket listen fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_listen_complete(void * ioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_LISTEN_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_listen_complete " "Socket listen complete ioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, fd);
        }
    }
}

static inline void trace_qio_channel_socket_dgram_sync(void * ioc, void * localAddr, void * remoteAddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_SYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_dgram_sync " "Socket dgram sync ioc=%p localAddr=%p remoteAddr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, localAddr, remoteAddr);
        }
    }
}

static inline void trace_qio_channel_socket_dgram_async(void * ioc, void * localAddr, void * remoteAddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_dgram_async " "Socket dgram async ioc=%p localAddr=%p remoteAddr=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, localAddr, remoteAddr);
        }
    }
}

static inline void trace_qio_channel_socket_dgram_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_dgram_fail " "Socket dgram fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_dgram_complete(void * ioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_DGRAM_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_dgram_complete " "Socket dgram complete ioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, fd);
        }
    }
}

static inline void trace_qio_channel_socket_accept(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_accept " "Socket accept start ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_accept_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_accept_fail " "Socket accept fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_socket_accept_complete(void * ioc, void * cioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_SOCKET_ACCEPT_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_socket_accept_complete " "Socket accept complete ioc=%p cioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, cioc, fd);
        }
    }
}

static inline void trace_qio_channel_file_new_fd(void * ioc, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_FILE_NEW_FD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_file_new_fd " "File new fd ioc=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, fd);
        }
    }
}

static inline void trace_qio_channel_file_new_path(void * ioc, const char * path, int flags, int mode, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_FILE_NEW_PATH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_file_new_path " "File new fd ioc=%p path=%s flags=%d mode=%d fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, path, flags, mode, fd);
        }
    }
}

static inline void trace_qio_channel_tls_new_client(void * ioc, void * master, void * creds, const char * hostname)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_NEW_CLIENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_new_client " "TLS new client ioc=%p master=%p creds=%p hostname=%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, master, creds, hostname);
        }
    }
}

static inline void trace_qio_channel_tls_new_server(void * ioc, void * master, void * creds, const char * aclname)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_NEW_SERVER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_new_server " "TLS new client ioc=%p master=%p creds=%p acltname=%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, master, creds, aclname);
        }
    }
}

static inline void trace_qio_channel_tls_handshake_start(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_handshake_start " "TLS handshake start ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_tls_handshake_pending(void * ioc, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_PENDING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_handshake_pending " "TLS handshake pending ioc=%p status=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, status);
        }
    }
}

static inline void trace_qio_channel_tls_handshake_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_handshake_fail " "TLS handshake fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_tls_handshake_complete(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_HANDSHAKE_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_handshake_complete " "TLS handshake complete ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_tls_credentials_allow(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_ALLOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_credentials_allow " "TLS credentials allow ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_tls_credentials_deny(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_TLS_CREDENTIALS_DENY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_tls_credentials_deny " "TLS credentials deny ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_websock_new_server(void * ioc, void * master)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_NEW_SERVER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_new_server " "Websock new client ioc=%p master=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, master);
        }
    }
}

static inline void trace_qio_channel_websock_handshake_start(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_handshake_start " "Websock handshake start ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_websock_handshake_pending(void * ioc, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_PENDING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_handshake_pending " "Websock handshake pending ioc=%p status=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, status);
        }
    }
}

static inline void trace_qio_channel_websock_handshake_reply(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_REPLY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_handshake_reply " "Websock handshake reply ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_websock_handshake_fail(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_handshake_fail " "Websock handshake fail ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_websock_handshake_complete(void * ioc)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_WEBSOCK_HANDSHAKE_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_websock_handshake_complete " "Websock handshake complete ioc=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc);
        }
    }
}

static inline void trace_qio_channel_command_new_pid(void * ioc, int writefd, int readfd, int pid)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_NEW_PID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_command_new_pid " "Command new pid ioc=%p writefd=%d readfd=%d pid=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, writefd, readfd, pid);
        }
    }
}

static inline void trace_qio_channel_command_new_spawn(void * ioc, const char * binary, int flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_NEW_SPAWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_command_new_spawn " "Command new spawn ioc=%p binary=%s flags=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, binary, flags);
        }
    }
}

static inline void trace_qio_channel_command_abort(void * ioc, int pid)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_ABORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_command_abort " "Command abort ioc=%p pid=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, pid);
        }
    }
}

static inline void trace_qio_channel_command_wait(void * ioc, int pid, int ret, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_QIO_CHANNEL_COMMAND_WAIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:qio_channel_command_wait " "Command abort ioc=%p pid=%d ret=%d status=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioc, pid, ret, status);
        }
    }
}
#endif /* TRACE_IO_GENERATED_TRACERS_H */
