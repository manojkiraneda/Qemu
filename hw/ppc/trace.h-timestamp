/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_PPC_GENERATED_TRACERS_H
#define TRACE_HW_PPC_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_SPAPR_PCI_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_SETUP_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_WRITE_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_LSI_SET_EVENT;
extern TraceEvent _TRACE_SPAPR_PCI_MSI_RETRY_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_FAILED_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_CONTINUE_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_PVR_TRY_EVENT;
extern TraceEvent _TRACE_SPAPR_CAS_PVR_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_PUT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_GET_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PCI_STUFF_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_XLATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_NEW_TABLE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_PRE_SAVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_POST_LOAD_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_QUERY_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_CREATE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_REMOVE_EVENT;
extern TraceEvent _TRACE_SPAPR_IOMMU_DDW_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DEFERRING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_INDICATOR_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_CONFIGURED_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_SET_CONFIGURED_SKIPPING_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_ENTITY_SENSE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_ATTACH_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_DETACH_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_AWAITING_ISOLATED_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_AWAITING_UNUSABLE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_AWAITING_ALLOCATION_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_RESET_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_CHILD_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_REALIZE_COMPLETE_EVENT;
extern TraceEvent _TRACE_SPAPR_DRC_UNREALIZE_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_PARSE_VECTOR_EVENT;
extern TraceEvent _TRACE_SPAPR_OVEC_POPULATE_DT_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_SET_INDICATOR_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_SET_INDICATOR_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_EVENT;
extern TraceEvent _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_MISSING_FDT_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_H_REG_CRQ_EVENT;
extern TraceEvent _TRACE_SPAPR_VIO_FREE_CRQ_EVENT;
extern TraceEvent _TRACE_PPC_TB_ADJUST_EVENT;
extern TraceEvent _TRACE_PREP_IO_800_WRITEB_EVENT;
extern TraceEvent _TRACE_PREP_IO_800_READB_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_READ_EVENT;
extern TraceEvent _TRACE_PREP_SYSTEMIO_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_ID_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_PRESENCE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_READ_EVENT;
extern TraceEvent _TRACE_RS6000MC_SIZE_WRITE_EVENT;
extern TraceEvent _TRACE_RS6000MC_PARITY_READ_EVENT;
extern TraceEvent _TRACE_MAC99_UNINORTH_WRITE_EVENT;
extern TraceEvent _TRACE_MAC99_UNINORTH_READ_EVENT;
extern TraceEvent _TRACE_PPC4XX_PCI_MAP_IRQ_EVENT;
extern TraceEvent _TRACE_PPC4XX_PCI_SET_IRQ_EVENT;
extern uint16_t _TRACE_SPAPR_PCI_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_SETUP_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_WRITE_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_LSI_SET_DSTATE;
extern uint16_t _TRACE_SPAPR_PCI_MSI_RETRY_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_FAILED_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_CONTINUE_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_PVR_TRY_DSTATE;
extern uint16_t _TRACE_SPAPR_CAS_PVR_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_PUT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_GET_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PCI_STUFF_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_XLATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_NEW_TABLE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_PRE_SAVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_POST_LOAD_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_QUERY_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_CREATE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_REMOVE_DSTATE;
extern uint16_t _TRACE_SPAPR_IOMMU_DDW_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DEFERRING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_INDICATOR_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_CONFIGURED_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_SET_CONFIGURED_SKIPPING_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_ENTITY_SENSE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_ATTACH_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_DETACH_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_AWAITING_ISOLATED_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_AWAITING_UNUSABLE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_AWAITING_ALLOCATION_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_RESET_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_CHILD_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_REALIZE_COMPLETE_DSTATE;
extern uint16_t _TRACE_SPAPR_DRC_UNREALIZE_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_PARSE_VECTOR_DSTATE;
extern uint16_t _TRACE_SPAPR_OVEC_POPULATE_DT_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_SET_INDICATOR_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_SET_INDICATOR_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_DSTATE;
extern uint16_t _TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_MISSING_FDT_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_H_REG_CRQ_DSTATE;
extern uint16_t _TRACE_SPAPR_VIO_FREE_CRQ_DSTATE;
extern uint16_t _TRACE_PPC_TB_ADJUST_DSTATE;
extern uint16_t _TRACE_PREP_IO_800_WRITEB_DSTATE;
extern uint16_t _TRACE_PREP_IO_800_READB_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_READ_DSTATE;
extern uint16_t _TRACE_PREP_SYSTEMIO_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_ID_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_PRESENCE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_READ_DSTATE;
extern uint16_t _TRACE_RS6000MC_SIZE_WRITE_DSTATE;
extern uint16_t _TRACE_RS6000MC_PARITY_READ_DSTATE;
extern uint16_t _TRACE_MAC99_UNINORTH_WRITE_DSTATE;
extern uint16_t _TRACE_MAC99_UNINORTH_READ_DSTATE;
extern uint16_t _TRACE_PPC4XX_PCI_MAP_IRQ_DSTATE;
extern uint16_t _TRACE_PPC4XX_PCI_SET_IRQ_DSTATE;
#define TRACE_SPAPR_PCI_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_SETUP_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI_ENABLED 1
#define TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_WRITE_ENABLED 1
#define TRACE_SPAPR_PCI_LSI_SET_ENABLED 1
#define TRACE_SPAPR_PCI_MSI_RETRY_ENABLED 1
#define TRACE_SPAPR_CAS_FAILED_ENABLED 1
#define TRACE_SPAPR_CAS_CONTINUE_ENABLED 1
#define TRACE_SPAPR_CAS_PVR_TRY_ENABLED 1
#define TRACE_SPAPR_CAS_PVR_ENABLED 1
#define TRACE_SPAPR_IOMMU_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_PUT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_GET_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_INDIRECT_ENABLED 1
#define TRACE_SPAPR_IOMMU_PCI_STUFF_ENABLED 1
#define TRACE_SPAPR_IOMMU_XLATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_NEW_TABLE_ENABLED 1
#define TRACE_SPAPR_IOMMU_PRE_SAVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_POST_LOAD_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_QUERY_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_CREATE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_REMOVE_ENABLED 1
#define TRACE_SPAPR_IOMMU_DDW_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DEFERRING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_INDICATOR_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_ENABLED 1
#define TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING_ENABLED 1
#define TRACE_SPAPR_DRC_SET_CONFIGURED_ENABLED 1
#define TRACE_SPAPR_DRC_SET_CONFIGURED_SKIPPING_ENABLED 1
#define TRACE_SPAPR_DRC_ENTITY_SENSE_ENABLED 1
#define TRACE_SPAPR_DRC_ATTACH_ENABLED 1
#define TRACE_SPAPR_DRC_DETACH_ENABLED 1
#define TRACE_SPAPR_DRC_AWAITING_ISOLATED_ENABLED 1
#define TRACE_SPAPR_DRC_AWAITING_UNUSABLE_ENABLED 1
#define TRACE_SPAPR_DRC_AWAITING_ALLOCATION_ENABLED 1
#define TRACE_SPAPR_DRC_RESET_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_CHILD_ENABLED 1
#define TRACE_SPAPR_DRC_REALIZE_COMPLETE_ENABLED 1
#define TRACE_SPAPR_DRC_UNREALIZE_ENABLED 1
#define TRACE_SPAPR_OVEC_PARSE_VECTOR_ENABLED 1
#define TRACE_SPAPR_OVEC_POPULATE_DT_ENABLED 1
#define TRACE_SPAPR_RTAS_SET_INDICATOR_INVALID_ENABLED 1
#define TRACE_SPAPR_RTAS_SET_INDICATOR_NOT_SUPPORTED_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED_ENABLED 1
#define TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID_ENABLED 1
#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID_ENABLED 1
#define TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_MISSING_FDT_ENABLED 1
#define TRACE_SPAPR_VIO_H_REG_CRQ_ENABLED 1
#define TRACE_SPAPR_VIO_FREE_CRQ_ENABLED 1
#define TRACE_PPC_TB_ADJUST_ENABLED 1
#define TRACE_PREP_IO_800_WRITEB_ENABLED 1
#define TRACE_PREP_IO_800_READB_ENABLED 1
#define TRACE_PREP_SYSTEMIO_READ_ENABLED 1
#define TRACE_PREP_SYSTEMIO_WRITE_ENABLED 1
#define TRACE_RS6000MC_ID_READ_ENABLED 1
#define TRACE_RS6000MC_PRESENCE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_READ_ENABLED 1
#define TRACE_RS6000MC_SIZE_WRITE_ENABLED 1
#define TRACE_RS6000MC_PARITY_READ_ENABLED 1
#define TRACE_MAC99_UNINORTH_WRITE_ENABLED 1
#define TRACE_MAC99_UNINORTH_READ_ENABLED 1
#define TRACE_PPC4XX_PCI_MAP_IRQ_ENABLED 1
#define TRACE_PPC4XX_PCI_SET_IRQ_ENABLED 1
#include "qemu/log.h"


static inline void trace_spapr_pci_msi(const char * msg, uint32_t ca)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_MSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_msi " "%s (cfg=%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , msg, ca);
        }
    }
}

static inline void trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_SETUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, vector, addr);
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_change_msi(unsigned cfg, unsigned func, unsigned req, unsigned first)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_rtas_ibm_change_msi " "cfgaddr %x func %u, requested %u, first irq %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cfg, func, req, first);
        }
    }
}

static inline void trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ioa, intr);
        }
    }
}

static inline void trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_msi_write " "@%"PRIx64"<=%"PRIx64" IRQ %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, data, dt_irq);
        }
    }
}

static inline void trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_LSI_SET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , busname, pin, irq);
        }
    }
}

static inline void trace_spapr_pci_msi_retry(unsigned config_addr, unsigned req_num, unsigned max_irqs)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_PCI_MSI_RETRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_pci_msi_retry " "Guest device at %x asked %u, have only %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , config_addr, req_num, max_irqs);
        }
    }
}

static inline void trace_spapr_cas_failed(unsigned long n)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_CAS_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_cas_failed " "DT diff buffer is too small: %ld bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , n);
        }
    }
}

static inline void trace_spapr_cas_continue(unsigned long n)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_CAS_CONTINUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_cas_continue " "Copy changes to the guest: %ld bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , n);
        }
    }
}

static inline void trace_spapr_cas_pvr_try(uint32_t pvr)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_CAS_PVR_TRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_cas_pvr_try " "%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pvr);
        }
    }
}

static inline void trace_spapr_cas_pvr(uint32_t cur_pvr, bool explicit_match, uint32_t new_pvr)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_CAS_PVR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_cas_pvr " "current=%x, explicit_match=%u, new=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cur_pvr, explicit_match, new_pvr);
        }
    }
}

static inline void trace_spapr_iommu_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_put " "liobn=%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce, ret);
        }
    }
}

static inline void trace_spapr_iommu_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_GET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_get " "liobn=%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, ret, tce);
        }
    }
}

static inline void trace_spapr_iommu_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_INDIRECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_indirect " "liobn=%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce, iobaN, tceN, ret);
        }
    }
}

static inline void trace_spapr_iommu_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_STUFF)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_stuff " "liobn=%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce_value, npages, ret);
        }
    }
}

static inline void trace_spapr_iommu_pci_put(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_PUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_pci_put " "liobn=%"PRIx64" ioba=0x%"PRIx64" tce=0x%"PRIx64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce, ret);
        }
    }
}

static inline void trace_spapr_iommu_pci_get(uint64_t liobn, uint64_t ioba, uint64_t ret, uint64_t tce)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_GET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_pci_get " "liobn=%"PRIx64" ioba=0x%"PRIx64" ret=%"PRId64" tce=0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, ret, tce);
        }
    }
}

static inline void trace_spapr_iommu_pci_indirect(uint64_t liobn, uint64_t ioba, uint64_t tce, uint64_t iobaN, uint64_t tceN, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_INDIRECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_pci_indirect " "liobn=%"PRIx64" ioba=0x%"PRIx64" tcelist=0x%"PRIx64" iobaN=0x%"PRIx64" tceN=0x%"PRIx64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce, iobaN, tceN, ret);
        }
    }
}

static inline void trace_spapr_iommu_pci_stuff(uint64_t liobn, uint64_t ioba, uint64_t tce_value, uint64_t npages, uint64_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PCI_STUFF)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_pci_stuff " "liobn=%"PRIx64" ioba=0x%"PRIx64" tcevalue=0x%"PRIx64" npages=%"PRId64" ret=%"PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce_value, npages, ret);
        }
    }
}

static inline void trace_spapr_iommu_xlate(uint64_t liobn, uint64_t ioba, uint64_t tce, unsigned perm, unsigned pgsize)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_XLATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_xlate " "liobn=%"PRIx64" 0x%"PRIx64" -> 0x%"PRIx64" perm=%u mask=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, ioba, tce, perm, pgsize);
        }
    }
}

static inline void trace_spapr_iommu_new_table(uint64_t liobn, void * table, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_NEW_TABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_new_table " "liobn=%"PRIx64" table=%p fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, table, fd);
        }
    }
}

static inline void trace_spapr_iommu_pre_save(uint64_t liobn, uint32_t nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_PRE_SAVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_pre_save " "liobn=%"PRIx64" %"PRIx32" bus_offset=%"PRIx64" ps=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, nb, offs, ps);
        }
    }
}

static inline void trace_spapr_iommu_post_load(uint64_t liobn, uint32_t pre_nb, uint32_t post_nb, uint64_t offs, uint32_t ps)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_POST_LOAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_post_load " "liobn=%"PRIx64" %"PRIx32" => %"PRIx32" bus_offset=%"PRIx64" ps=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn, pre_nb, post_nb, offs, ps);
        }
    }
}

static inline void trace_spapr_iommu_ddw_query(uint64_t buid, uint32_t cfgaddr, unsigned wa, uint64_t win_size, uint32_t pgmask)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_QUERY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_ddw_query " "buid=%"PRIx64" addr=%"PRIx32", %u windows available, max window size=%"PRIx64", mask=%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buid, cfgaddr, wa, win_size, pgmask);
        }
    }
}

static inline void trace_spapr_iommu_ddw_create(uint64_t buid, uint32_t cfgaddr, uint64_t pg_size, uint64_t req_size, uint64_t start, uint32_t liobn)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_CREATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_ddw_create " "buid=%"PRIx64" addr=%"PRIx32", page size=0x%"PRIx64", requested=0x%"PRIx64", start addr=%"PRIx64", liobn=%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buid, cfgaddr, pg_size, req_size, start, liobn);
        }
    }
}

static inline void trace_spapr_iommu_ddw_remove(uint32_t liobn)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_REMOVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_ddw_remove " "liobn=%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , liobn);
        }
    }
}

static inline void trace_spapr_iommu_ddw_reset(uint64_t buid, uint32_t cfgaddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_IOMMU_DDW_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_iommu_ddw_reset " "buid=%"PRIx64" addr=%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buid, cfgaddr);
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state(uint32_t index, int state)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_isolation_state " "drc: 0x%"PRIx32", state: %"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, state);
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state_finalizing(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_FINALIZING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_isolation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_set_isolation_state_deferring(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ISOLATION_STATE_DEFERRING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_isolation_state_deferring " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_set_indicator_state(uint32_t index, int state)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_INDICATOR_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_indicator_state " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, state);
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state(uint32_t index, int state)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_allocation_state " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, state);
        }
    }
}

static inline void trace_spapr_drc_set_allocation_state_finalizing(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_ALLOCATION_STATE_FINALIZING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_allocation_state_finalizing " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_set_configured(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_CONFIGURED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_configured " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_set_configured_skipping(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_SET_CONFIGURED_SKIPPING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_set_configured_skipping " "drc: 0x%"PRIx32", isolated device" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_entity_sense(uint32_t index, int state)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_ENTITY_SENSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_entity_sense " "drc: 0x%"PRIx32", state: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, state);
        }
    }
}

static inline void trace_spapr_drc_attach(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_ATTACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_attach " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_detach(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_DETACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_detach " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_awaiting_isolated(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_AWAITING_ISOLATED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_awaiting_isolated " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_awaiting_unusable(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_AWAITING_UNUSABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_awaiting_unusable " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_awaiting_allocation(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_AWAITING_ALLOCATION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_awaiting_allocation " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_reset(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_reset " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_realize(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_realize " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_realize_child(uint32_t index, char * childname)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_CHILD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_realize_child " "drc: 0x%"PRIx32", child name: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, childname);
        }
    }
}

static inline void trace_spapr_drc_realize_complete(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_REALIZE_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_realize_complete " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_drc_unrealize(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_DRC_UNREALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_drc_unrealize " "drc: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_ovec_parse_vector(int vector, int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_OVEC_PARSE_VECTOR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_ovec_parse_vector " "read guest vector %2d, byte %3d / %3d: 0x%.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector, byte, vec_len, entry);
        }
    }
}

static inline void trace_spapr_ovec_populate_dt(int byte, uint16_t vec_len, uint8_t entry)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_OVEC_POPULATE_DT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_ovec_populate_dt " "encoding guest vector byte %3d / %3d: 0x%.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , byte, vec_len, entry);
        }
    }
}

static inline void trace_spapr_rtas_set_indicator_invalid(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_SET_INDICATOR_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_set_indicator_invalid " "sensor index: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_rtas_set_indicator_not_supported(uint32_t index, uint32_t type)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_SET_INDICATOR_NOT_SUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_set_indicator_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, type);
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_not_supported(uint32_t index, uint32_t type)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_NOT_SUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_get_sensor_state_not_supported " "sensor index: 0x%"PRIx32", type: %"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, type);
        }
    }
}

static inline void trace_spapr_rtas_get_sensor_state_invalid(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_GET_SENSOR_STATE_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_get_sensor_state_invalid " "sensor index: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_rtas_ibm_configure_connector_invalid(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_ibm_configure_connector_invalid " "DRC index: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_rtas_ibm_configure_connector_missing_fdt(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_RTAS_IBM_CONFIGURE_CONNECTOR_MISSING_FDT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_rtas_ibm_configure_connector_missing_fdt " "DRC index: 0x%"PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_spapr_vio_h_reg_crq(uint64_t reg, uint64_t queue_addr, uint64_t queue_len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VIO_H_REG_CRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vio_h_reg_crq " "CRQ for dev 0x%" PRIx64 " registered at 0x%" PRIx64 "/0x%" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, queue_addr, queue_len);
        }
    }
}

static inline void trace_spapr_vio_free_crq(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VIO_FREE_CRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vio_free_crq " "CRQ for dev 0x%" PRIx32 " freed" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_ppc_tb_adjust(uint64_t offs1, uint64_t offs2, int64_t diff, int64_t seconds)
{
    if (true) {
        if (trace_event_get_state(TRACE_PPC_TB_ADJUST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ppc_tb_adjust " "adjusted from 0x%"PRIx64" to 0x%"PRIx64", diff %"PRId64" (%"PRId64"s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , offs1, offs2, diff, seconds);
        }
    }
}

static inline void trace_prep_io_800_writeb(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PREP_IO_800_WRITEB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:prep_io_800_writeb " "0x%08" PRIx32 " => 0x%02" PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_prep_io_800_readb(uint32_t addr, uint32_t retval)
{
    if (true) {
        if (trace_event_get_state(TRACE_PREP_IO_800_READB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:prep_io_800_readb " "0x%08" PRIx32 " <= 0x%02" PRIx32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, retval);
        }
    }
}

static inline void trace_prep_systemio_read(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PREP_SYSTEMIO_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:prep_systemio_read " "read addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_prep_systemio_write(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PREP_SYSTEMIO_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:prep_systemio_write " "write addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_rs6000mc_id_read(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_RS6000MC_ID_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:rs6000mc_id_read " "read addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_rs6000mc_presence_read(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_RS6000MC_PRESENCE_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:rs6000mc_presence_read " "read addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_rs6000mc_size_read(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_RS6000MC_SIZE_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:rs6000mc_size_read " "read addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_rs6000mc_size_write(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_RS6000MC_SIZE_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:rs6000mc_size_write " "write addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_rs6000mc_parity_read(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_RS6000MC_PARITY_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:rs6000mc_parity_read " "read addr=%x val=%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_mac99_uninorth_write(uint64_t addr, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MAC99_UNINORTH_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mac99_uninorth_write " "addr=0x%" PRIx64 " val=0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_mac99_uninorth_read(uint64_t addr, uint64_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MAC99_UNINORTH_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mac99_uninorth_read " "addr=0x%" PRIx64 " val=0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_ppc4xx_pci_map_irq(int32_t devfn, int irq_num, int slot)
{
    if (true) {
        if (trace_event_get_state(TRACE_PPC4XX_PCI_MAP_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ppc4xx_pci_map_irq " "devfn %x irq %d -> %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , devfn, irq_num, slot);
        }
    }
}

static inline void trace_ppc4xx_pci_set_irq(int irq_num)
{
    if (true) {
        if (trace_event_get_state(TRACE_PPC4XX_PCI_SET_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:ppc4xx_pci_set_irq " "PCI irq %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , irq_num);
        }
    }
}
#endif /* TRACE_HW_PPC_GENERATED_TRACERS_H */
