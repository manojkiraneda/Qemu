/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_NET_GENERATED_TRACERS_H
#define TRACE_HW_NET_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_LANCE_MEM_READW_EVENT;
extern TraceEvent _TRACE_LANCE_MEM_WRITEW_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_MDIO_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_MDIO_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_TX_FRAME_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_RX_FRAME_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_RX_TRANSFER_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_RAISE_IRQ_RX_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_LOWER_IRQ_RX_EVENT;
extern TraceEvent _TRACE_MILKYMIST_MINIMAC2_PULSE_IRQ_TX_EVENT;
extern TraceEvent _TRACE_MIPSNET_SEND_EVENT;
extern TraceEvent _TRACE_MIPSNET_RECEIVE_EVENT;
extern TraceEvent _TRACE_MIPSNET_READ_EVENT;
extern TraceEvent _TRACE_MIPSNET_WRITE_EVENT;
extern TraceEvent _TRACE_MIPSNET_IRQ_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_MII_WRITE_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_MII_READ_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_RECEIVE_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_RECEIVE_MCAST_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_RECEIVE_REJECT_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_RECEIVE_DESC_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_START_XMIT_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_REG_READ_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_REG_WRITE_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_DESC_READ_EVENT;
extern TraceEvent _TRACE_OPEN_ETH_DESC_WRITE_EVENT;
extern TraceEvent _TRACE_PCNET_S_RESET_EVENT;
extern TraceEvent _TRACE_PCNET_USER_INT_EVENT;
extern TraceEvent _TRACE_PCNET_ISR_CHANGE_EVENT;
extern TraceEvent _TRACE_PCNET_INIT_EVENT;
extern TraceEvent _TRACE_PCNET_RLEN_TLEN_EVENT;
extern TraceEvent _TRACE_PCNET_SS32_RDRA_TDRA_EVENT;
extern TraceEvent _TRACE_PCNET_APROM_WRITEB_EVENT;
extern TraceEvent _TRACE_PCNET_APROM_READB_EVENT;
extern TraceEvent _TRACE_PCNET_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_PCNET_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_WRITEB_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_WRITEW_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_WRITEL_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_READB_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_READW_EVENT;
extern TraceEvent _TRACE_PCNET_MMIO_READL_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_PARSED_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_ENTRY_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_NOT_XXP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_UDP_WITH_NO_CHECKSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_IP4_FRAGMENT_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_CSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_ENTRY_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_UDP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_TCP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_UDP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_TCP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_PH_CSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_CALC_CSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_ENTRY_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_TCP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_NOT_XXP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_IP4_FRAGMENT_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_WITH_NO_CHECKSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L4_CSUM_FIX_CSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_ENTRY_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_NOT_IP4_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_CSUM_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_IP4_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_IP4_TCP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_IP6_TCP_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_IP6_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_IP6_EX_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_HASH_EVENT;
extern TraceEvent _TRACE_NET_RX_PKT_RSS_ADD_CHUNK_EVENT;
extern TraceEvent _TRACE_E1000X_RX_CAN_RECV_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000X_VLAN_IS_VLAN_PKT_EVENT;
extern TraceEvent _TRACE_E1000X_RX_FLT_UCAST_MATCH_EVENT;
extern TraceEvent _TRACE_E1000X_RX_FLT_UCAST_MISMATCH_EVENT;
extern TraceEvent _TRACE_E1000X_RX_FLT_INEXACT_MISMATCH_EVENT;
extern TraceEvent _TRACE_E1000X_RX_LINK_DOWN_EVENT;
extern TraceEvent _TRACE_E1000X_RX_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000X_RX_OVERSIZED_EVENT;
extern TraceEvent _TRACE_E1000X_MAC_INDICATE_EVENT;
extern TraceEvent _TRACE_E1000X_LINK_NEGOTIATION_START_EVENT;
extern TraceEvent _TRACE_E1000X_LINK_NEGOTIATION_DONE_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_READ_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_MDIC_READ_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_MDIC_READ_UNHANDLED_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_MDIC_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_MDIC_WRITE_UNHANDLED_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_CTRL_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_CTRL_SW_RESET_EVENT;
extern TraceEvent _TRACE_E1000E_CORE_CTRL_PHY_RESET_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_AUTONEG_FLOWCTL_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_SET_PARAMS_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_READ_PARAMS_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_SET_EXT_PARAMS_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_STATUS_EVENT;
extern TraceEvent _TRACE_E1000E_LINK_STATUS_CHANGED_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_REGS_WRITE_RO_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_REGS_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_REGS_READ_UNKNOWN_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_REGS_READ_TRIVIAL_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_REGS_WRITE_TRIVIAL_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_NO_TS_SUPPORT_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_NO_SNAP_SUPPORT_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_ISCSI_FILTERING_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_NFSW_FILTERING_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_NFSR_FILTERING_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_E1000E_TX_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_TX_DESCR_EVENT;
extern TraceEvent _TRACE_E1000E_RING_FREE_SPACE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_CAN_RECV_RINGS_FULL_EVENT;
extern TraceEvent _TRACE_E1000E_RX_CAN_RECV_EVENT;
extern TraceEvent _TRACE_E1000E_RX_HAS_BUFFERS_EVENT;
extern TraceEvent _TRACE_E1000E_RX_NULL_DESCRIPTOR_EVENT;
extern TraceEvent _TRACE_E1000E_RX_FLT_VLAN_MISMATCH_EVENT;
extern TraceEvent _TRACE_E1000E_RX_FLT_VLAN_MATCH_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESC_PS_READ_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESC_PS_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESC_BUFF_SIZES_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESC_LEN_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESC_BUFF_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_DESCR_EVENT;
extern TraceEvent _TRACE_E1000E_RX_SET_RCTL_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RECEIVE_IOV_EVENT;
extern TraceEvent _TRACE_E1000E_RX_FLT_DROPPED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_WRITTEN_TO_GUEST_EVENT;
extern TraceEvent _TRACE_E1000E_RX_NOT_WRITTEN_TO_GUEST_EVENT;
extern TraceEvent _TRACE_E1000E_RX_INTERRUPT_SET_EVENT;
extern TraceEvent _TRACE_E1000E_RX_INTERRUPT_DELAYED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_SET_CSO_EVENT;
extern TraceEvent _TRACE_E1000E_RX_SET_RDT_EVENT;
extern TraceEvent _TRACE_E1000E_RX_SET_RFCTL_EVENT;
extern TraceEvent _TRACE_E1000E_RX_START_RECV_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_STARTED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_TYPE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_IP4_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_IP6_RFCTL_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_IP6_EVENT;
extern TraceEvent _TRACE_E1000E_RX_RSS_DISPATCHED_TO_QUEUE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_PROTOCOLS_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_VLAN_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_RSS_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_IP_ID_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_ACK_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_PKT_TYPE_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_NO_VIRTHDR_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_VIRTHDR_NO_CSUM_INFO_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_L3_CSO_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_L4_CSO_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_L3_CSUM_VALIDATION_FAILED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_L4_CSUM_VALIDATION_FAILED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_STATUS_FLAGS_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_IPV6_SUM_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_RX_METADATA_IPV6_FILTERING_DISABLED_EVENT;
extern TraceEvent _TRACE_E1000E_VLAN_VET_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_MSI_NOTIFY_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_INTERRUPTS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_MSI_NOTIFY_POSTPONED_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_LEGACY_NOTIFY_POSTPONED_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_VEC_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_MSIX_NOTIFY_POSTPONED_VEC_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_LEGACY_NOTIFY_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_MSIX_NOTIFY_VEC_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_POSTPONED_BY_XITR_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_CLEAR_IMS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_SET_IMS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_FIX_ICR_ASSERTED_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ADD_MSI_OTHER_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_PENDING_INTERRUPTS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_SET_CAUSE_ENTRY_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_SET_CAUSE_EXIT_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_WRITE_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_WRITE_ICS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_PROCESS_IAME_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_READ_ICS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_READ_IMS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_READ_ENTRY_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_READ_EXIT_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_CLEAR_ZERO_IMS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_CLEAR_IAME_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_IAM_CLEAR_EIAME_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ICR_CLEAR_EIAC_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_IMS_CLEAR_SET_IMC_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_FIRE_DELAYED_INTERRUPTS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_REARM_TIMER_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_THROTTLING_TIMER_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_RDTR_FPD_RUNNING_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_RDTR_FPD_NOT_RUNNING_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_TIDV_FPD_RUNNING_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_TIDV_FPD_NOT_RUNNING_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_EITR_SET_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ITR_SET_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_FIRE_ALL_TIMERS_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_ADDING_DELAYED_CAUSES_EVENT;
extern TraceEvent _TRACE_E1000E_IRQ_MSIX_PENDING_CLEARING_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_MSIX_VEC_WRONG_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_MSIX_INVALID_EVENT;
extern TraceEvent _TRACE_E1000E_MAC_SET_PERMANENT_EVENT;
extern TraceEvent _TRACE_E1000E_MAC_SET_SW_EVENT;
extern TraceEvent _TRACE_E1000E_CB_PCI_REALIZE_EVENT;
extern TraceEvent _TRACE_E1000E_CB_PCI_UNINIT_EVENT;
extern TraceEvent _TRACE_E1000E_CB_QDEV_RESET_EVENT;
extern TraceEvent _TRACE_E1000E_CB_PRE_SAVE_EVENT;
extern TraceEvent _TRACE_E1000E_CB_POST_LOAD_EVENT;
extern TraceEvent _TRACE_E1000E_IO_WRITE_ADDR_EVENT;
extern TraceEvent _TRACE_E1000E_IO_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_E1000E_IO_READ_ADDR_EVENT;
extern TraceEvent _TRACE_E1000E_IO_READ_DATA_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_IO_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_IO_READ_UNKNOWN_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_IO_ADDR_UNDEFINED_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_IO_ADDR_FLASH_EVENT;
extern TraceEvent _TRACE_E1000E_WRN_IO_ADDR_UNKNOWN_EVENT;
extern TraceEvent _TRACE_E1000E_MSI_INIT_FAIL_EVENT;
extern TraceEvent _TRACE_E1000E_MSIX_INIT_FAIL_EVENT;
extern TraceEvent _TRACE_E1000E_MSIX_USE_VECTOR_FAIL_EVENT;
extern TraceEvent _TRACE_E1000E_CFG_SUPPORT_VIRTIO_EVENT;
extern TraceEvent _TRACE_E1000E_VM_STATE_RUNNING_EVENT;
extern TraceEvent _TRACE_E1000E_VM_STATE_STOPPED_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_POOL_FOUND_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_FOUND_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_RECEIVE_DMA_COMPLETED_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_RECEIVE_WROTE_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_CREATE_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_PAGE_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_H_ADD_LOGICAL_LAN_BUFFER_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_RXBUFS_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_BUF_DESC_EVENT;
extern TraceEvent _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_TOTAL_EVENT;
extern uint16_t _TRACE_LANCE_MEM_READW_DSTATE;
extern uint16_t _TRACE_LANCE_MEM_WRITEW_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_MDIO_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_MDIO_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_TX_FRAME_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_RX_FRAME_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_RX_TRANSFER_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_RAISE_IRQ_RX_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_LOWER_IRQ_RX_DSTATE;
extern uint16_t _TRACE_MILKYMIST_MINIMAC2_PULSE_IRQ_TX_DSTATE;
extern uint16_t _TRACE_MIPSNET_SEND_DSTATE;
extern uint16_t _TRACE_MIPSNET_RECEIVE_DSTATE;
extern uint16_t _TRACE_MIPSNET_READ_DSTATE;
extern uint16_t _TRACE_MIPSNET_WRITE_DSTATE;
extern uint16_t _TRACE_MIPSNET_IRQ_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_MII_WRITE_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_MII_READ_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_RECEIVE_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_RECEIVE_MCAST_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_RECEIVE_REJECT_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_RECEIVE_DESC_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_START_XMIT_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_REG_READ_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_REG_WRITE_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_DESC_READ_DSTATE;
extern uint16_t _TRACE_OPEN_ETH_DESC_WRITE_DSTATE;
extern uint16_t _TRACE_PCNET_S_RESET_DSTATE;
extern uint16_t _TRACE_PCNET_USER_INT_DSTATE;
extern uint16_t _TRACE_PCNET_ISR_CHANGE_DSTATE;
extern uint16_t _TRACE_PCNET_INIT_DSTATE;
extern uint16_t _TRACE_PCNET_RLEN_TLEN_DSTATE;
extern uint16_t _TRACE_PCNET_SS32_RDRA_TDRA_DSTATE;
extern uint16_t _TRACE_PCNET_APROM_WRITEB_DSTATE;
extern uint16_t _TRACE_PCNET_APROM_READB_DSTATE;
extern uint16_t _TRACE_PCNET_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_PCNET_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_WRITEB_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_WRITEW_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_WRITEL_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_READB_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_READW_DSTATE;
extern uint16_t _TRACE_PCNET_MMIO_READL_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_PARSED_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_ENTRY_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_NOT_XXP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_UDP_WITH_NO_CHECKSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_IP4_FRAGMENT_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_CSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_ENTRY_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_UDP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_TCP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_UDP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_TCP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_PH_CSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_CALC_CSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_ENTRY_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_TCP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_NOT_XXP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_IP4_FRAGMENT_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_WITH_NO_CHECKSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L4_CSUM_FIX_CSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_ENTRY_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_NOT_IP4_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_CSUM_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_IP4_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_IP4_TCP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_IP6_TCP_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_IP6_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_IP6_EX_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_HASH_DSTATE;
extern uint16_t _TRACE_NET_RX_PKT_RSS_ADD_CHUNK_DSTATE;
extern uint16_t _TRACE_E1000X_RX_CAN_RECV_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000X_VLAN_IS_VLAN_PKT_DSTATE;
extern uint16_t _TRACE_E1000X_RX_FLT_UCAST_MATCH_DSTATE;
extern uint16_t _TRACE_E1000X_RX_FLT_UCAST_MISMATCH_DSTATE;
extern uint16_t _TRACE_E1000X_RX_FLT_INEXACT_MISMATCH_DSTATE;
extern uint16_t _TRACE_E1000X_RX_LINK_DOWN_DSTATE;
extern uint16_t _TRACE_E1000X_RX_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000X_RX_OVERSIZED_DSTATE;
extern uint16_t _TRACE_E1000X_MAC_INDICATE_DSTATE;
extern uint16_t _TRACE_E1000X_LINK_NEGOTIATION_START_DSTATE;
extern uint16_t _TRACE_E1000X_LINK_NEGOTIATION_DONE_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_READ_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_MDIC_READ_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_MDIC_READ_UNHANDLED_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_MDIC_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_MDIC_WRITE_UNHANDLED_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_CTRL_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_CTRL_SW_RESET_DSTATE;
extern uint16_t _TRACE_E1000E_CORE_CTRL_PHY_RESET_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_AUTONEG_FLOWCTL_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_SET_PARAMS_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_READ_PARAMS_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_SET_EXT_PARAMS_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_STATUS_DSTATE;
extern uint16_t _TRACE_E1000E_LINK_STATUS_CHANGED_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_REGS_WRITE_RO_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_REGS_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_REGS_READ_UNKNOWN_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_REGS_READ_TRIVIAL_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_REGS_WRITE_TRIVIAL_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_NO_TS_SUPPORT_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_NO_SNAP_SUPPORT_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_ISCSI_FILTERING_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_NFSW_FILTERING_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_NFSR_FILTERING_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_E1000E_TX_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_TX_DESCR_DSTATE;
extern uint16_t _TRACE_E1000E_RING_FREE_SPACE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_CAN_RECV_RINGS_FULL_DSTATE;
extern uint16_t _TRACE_E1000E_RX_CAN_RECV_DSTATE;
extern uint16_t _TRACE_E1000E_RX_HAS_BUFFERS_DSTATE;
extern uint16_t _TRACE_E1000E_RX_NULL_DESCRIPTOR_DSTATE;
extern uint16_t _TRACE_E1000E_RX_FLT_VLAN_MISMATCH_DSTATE;
extern uint16_t _TRACE_E1000E_RX_FLT_VLAN_MATCH_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESC_PS_READ_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESC_PS_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESC_BUFF_SIZES_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESC_LEN_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESC_BUFF_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_DESCR_DSTATE;
extern uint16_t _TRACE_E1000E_RX_SET_RCTL_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RECEIVE_IOV_DSTATE;
extern uint16_t _TRACE_E1000E_RX_FLT_DROPPED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_WRITTEN_TO_GUEST_DSTATE;
extern uint16_t _TRACE_E1000E_RX_NOT_WRITTEN_TO_GUEST_DSTATE;
extern uint16_t _TRACE_E1000E_RX_INTERRUPT_SET_DSTATE;
extern uint16_t _TRACE_E1000E_RX_INTERRUPT_DELAYED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_SET_CSO_DSTATE;
extern uint16_t _TRACE_E1000E_RX_SET_RDT_DSTATE;
extern uint16_t _TRACE_E1000E_RX_SET_RFCTL_DSTATE;
extern uint16_t _TRACE_E1000E_RX_START_RECV_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_STARTED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_TYPE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_IP4_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_IP6_RFCTL_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_IP6_DSTATE;
extern uint16_t _TRACE_E1000E_RX_RSS_DISPATCHED_TO_QUEUE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_PROTOCOLS_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_VLAN_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_RSS_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_IP_ID_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_ACK_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_PKT_TYPE_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_NO_VIRTHDR_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_VIRTHDR_NO_CSUM_INFO_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_L3_CSO_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_L4_CSO_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_L3_CSUM_VALIDATION_FAILED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_L4_CSUM_VALIDATION_FAILED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_STATUS_FLAGS_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_IPV6_SUM_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_RX_METADATA_IPV6_FILTERING_DISABLED_DSTATE;
extern uint16_t _TRACE_E1000E_VLAN_VET_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_MSI_NOTIFY_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_INTERRUPTS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_MSI_NOTIFY_POSTPONED_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_LEGACY_NOTIFY_POSTPONED_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_VEC_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_MSIX_NOTIFY_POSTPONED_VEC_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_LEGACY_NOTIFY_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_MSIX_NOTIFY_VEC_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_POSTPONED_BY_XITR_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_CLEAR_IMS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_SET_IMS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_FIX_ICR_ASSERTED_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ADD_MSI_OTHER_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_PENDING_INTERRUPTS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_SET_CAUSE_ENTRY_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_SET_CAUSE_EXIT_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_WRITE_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_WRITE_ICS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_PROCESS_IAME_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_READ_ICS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_READ_IMS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_READ_ENTRY_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_READ_EXIT_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_CLEAR_ZERO_IMS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_CLEAR_IAME_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_IAM_CLEAR_EIAME_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ICR_CLEAR_EIAC_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_IMS_CLEAR_SET_IMC_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_FIRE_DELAYED_INTERRUPTS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_REARM_TIMER_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_THROTTLING_TIMER_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_RDTR_FPD_RUNNING_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_RDTR_FPD_NOT_RUNNING_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_TIDV_FPD_RUNNING_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_TIDV_FPD_NOT_RUNNING_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_EITR_SET_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ITR_SET_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_FIRE_ALL_TIMERS_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_ADDING_DELAYED_CAUSES_DSTATE;
extern uint16_t _TRACE_E1000E_IRQ_MSIX_PENDING_CLEARING_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_MSIX_VEC_WRONG_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_MSIX_INVALID_DSTATE;
extern uint16_t _TRACE_E1000E_MAC_SET_PERMANENT_DSTATE;
extern uint16_t _TRACE_E1000E_MAC_SET_SW_DSTATE;
extern uint16_t _TRACE_E1000E_CB_PCI_REALIZE_DSTATE;
extern uint16_t _TRACE_E1000E_CB_PCI_UNINIT_DSTATE;
extern uint16_t _TRACE_E1000E_CB_QDEV_RESET_DSTATE;
extern uint16_t _TRACE_E1000E_CB_PRE_SAVE_DSTATE;
extern uint16_t _TRACE_E1000E_CB_POST_LOAD_DSTATE;
extern uint16_t _TRACE_E1000E_IO_WRITE_ADDR_DSTATE;
extern uint16_t _TRACE_E1000E_IO_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_E1000E_IO_READ_ADDR_DSTATE;
extern uint16_t _TRACE_E1000E_IO_READ_DATA_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_IO_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_IO_READ_UNKNOWN_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_IO_ADDR_UNDEFINED_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_IO_ADDR_FLASH_DSTATE;
extern uint16_t _TRACE_E1000E_WRN_IO_ADDR_UNKNOWN_DSTATE;
extern uint16_t _TRACE_E1000E_MSI_INIT_FAIL_DSTATE;
extern uint16_t _TRACE_E1000E_MSIX_INIT_FAIL_DSTATE;
extern uint16_t _TRACE_E1000E_MSIX_USE_VECTOR_FAIL_DSTATE;
extern uint16_t _TRACE_E1000E_CFG_SUPPORT_VIRTIO_DSTATE;
extern uint16_t _TRACE_E1000E_VM_STATE_RUNNING_DSTATE;
extern uint16_t _TRACE_E1000E_VM_STATE_STOPPED_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_POOL_FOUND_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_FOUND_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_RECEIVE_DMA_COMPLETED_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_RECEIVE_WROTE_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_CREATE_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_ADD_RXBUF_TO_PAGE_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_H_ADD_LOGICAL_LAN_BUFFER_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_RXBUFS_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_BUF_DESC_DSTATE;
extern uint16_t _TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_TOTAL_DSTATE;
#define TRACE_LANCE_MEM_READW_ENABLED 1
#define TRACE_LANCE_MEM_WRITEW_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_MEMORY_READ_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_MEMORY_WRITE_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_MDIO_WRITE_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_MDIO_READ_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_TX_FRAME_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_RX_FRAME_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_RX_TRANSFER_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_RAISE_IRQ_RX_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_LOWER_IRQ_RX_ENABLED 1
#define TRACE_MILKYMIST_MINIMAC2_PULSE_IRQ_TX_ENABLED 1
#define TRACE_MIPSNET_SEND_ENABLED 1
#define TRACE_MIPSNET_RECEIVE_ENABLED 1
#define TRACE_MIPSNET_READ_ENABLED 1
#define TRACE_MIPSNET_WRITE_ENABLED 1
#define TRACE_MIPSNET_IRQ_ENABLED 1
#define TRACE_OPEN_ETH_MII_WRITE_ENABLED 1
#define TRACE_OPEN_ETH_MII_READ_ENABLED 1
#define TRACE_OPEN_ETH_UPDATE_IRQ_ENABLED 1
#define TRACE_OPEN_ETH_RECEIVE_ENABLED 1
#define TRACE_OPEN_ETH_RECEIVE_MCAST_ENABLED 1
#define TRACE_OPEN_ETH_RECEIVE_REJECT_ENABLED 1
#define TRACE_OPEN_ETH_RECEIVE_DESC_ENABLED 1
#define TRACE_OPEN_ETH_START_XMIT_ENABLED 1
#define TRACE_OPEN_ETH_REG_READ_ENABLED 1
#define TRACE_OPEN_ETH_REG_WRITE_ENABLED 1
#define TRACE_OPEN_ETH_DESC_READ_ENABLED 1
#define TRACE_OPEN_ETH_DESC_WRITE_ENABLED 1
#define TRACE_PCNET_S_RESET_ENABLED 1
#define TRACE_PCNET_USER_INT_ENABLED 1
#define TRACE_PCNET_ISR_CHANGE_ENABLED 1
#define TRACE_PCNET_INIT_ENABLED 1
#define TRACE_PCNET_RLEN_TLEN_ENABLED 1
#define TRACE_PCNET_SS32_RDRA_TDRA_ENABLED 1
#define TRACE_PCNET_APROM_WRITEB_ENABLED 1
#define TRACE_PCNET_APROM_READB_ENABLED 1
#define TRACE_PCNET_IOPORT_READ_ENABLED 1
#define TRACE_PCNET_IOPORT_WRITE_ENABLED 1
#define TRACE_PCNET_MMIO_WRITEB_ENABLED 1
#define TRACE_PCNET_MMIO_WRITEW_ENABLED 1
#define TRACE_PCNET_MMIO_WRITEL_ENABLED 1
#define TRACE_PCNET_MMIO_READB_ENABLED 1
#define TRACE_PCNET_MMIO_READW_ENABLED 1
#define TRACE_PCNET_MMIO_READL_ENABLED 1
#define TRACE_NET_RX_PKT_PARSED_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_ENTRY_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_NOT_XXP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_UDP_WITH_NO_CHECKSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_IP4_FRAGMENT_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_CSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_ENTRY_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_UDP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_TCP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_UDP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_TCP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_PH_CSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_CALC_CSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_ENTRY_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_TCP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_NOT_XXP_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_IP4_FRAGMENT_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_WITH_NO_CHECKSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L4_CSUM_FIX_CSUM_ENABLED 1
#define TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_ENTRY_ENABLED 1
#define TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_NOT_IP4_ENABLED 1
#define TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_CSUM_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_IP4_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_IP4_TCP_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_IP6_TCP_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_IP6_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_IP6_EX_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_HASH_ENABLED 1
#define TRACE_NET_RX_PKT_RSS_ADD_CHUNK_ENABLED 1
#define TRACE_E1000X_RX_CAN_RECV_DISABLED_ENABLED 1
#define TRACE_E1000X_VLAN_IS_VLAN_PKT_ENABLED 1
#define TRACE_E1000X_RX_FLT_UCAST_MATCH_ENABLED 1
#define TRACE_E1000X_RX_FLT_UCAST_MISMATCH_ENABLED 1
#define TRACE_E1000X_RX_FLT_INEXACT_MISMATCH_ENABLED 1
#define TRACE_E1000X_RX_LINK_DOWN_ENABLED 1
#define TRACE_E1000X_RX_DISABLED_ENABLED 1
#define TRACE_E1000X_RX_OVERSIZED_ENABLED 1
#define TRACE_E1000X_MAC_INDICATE_ENABLED 1
#define TRACE_E1000X_LINK_NEGOTIATION_START_ENABLED 1
#define TRACE_E1000X_LINK_NEGOTIATION_DONE_ENABLED 1
#define TRACE_E1000E_CORE_WRITE_ENABLED 1
#define TRACE_E1000E_CORE_READ_ENABLED 1
#define TRACE_E1000E_CORE_MDIC_READ_ENABLED 1
#define TRACE_E1000E_CORE_MDIC_READ_UNHANDLED_ENABLED 1
#define TRACE_E1000E_CORE_MDIC_WRITE_ENABLED 1
#define TRACE_E1000E_CORE_MDIC_WRITE_UNHANDLED_ENABLED 1
#define TRACE_E1000E_CORE_CTRL_WRITE_ENABLED 1
#define TRACE_E1000E_CORE_CTRL_SW_RESET_ENABLED 1
#define TRACE_E1000E_CORE_CTRL_PHY_RESET_ENABLED 1
#define TRACE_E1000E_LINK_AUTONEG_FLOWCTL_ENABLED 1
#define TRACE_E1000E_LINK_SET_PARAMS_ENABLED 1
#define TRACE_E1000E_LINK_READ_PARAMS_ENABLED 1
#define TRACE_E1000E_LINK_SET_EXT_PARAMS_ENABLED 1
#define TRACE_E1000E_LINK_STATUS_ENABLED 1
#define TRACE_E1000E_LINK_STATUS_CHANGED_ENABLED 1
#define TRACE_E1000E_WRN_REGS_WRITE_RO_ENABLED 1
#define TRACE_E1000E_WRN_REGS_WRITE_UNKNOWN_ENABLED 1
#define TRACE_E1000E_WRN_REGS_READ_UNKNOWN_ENABLED 1
#define TRACE_E1000E_WRN_REGS_READ_TRIVIAL_ENABLED 1
#define TRACE_E1000E_WRN_REGS_WRITE_TRIVIAL_ENABLED 1
#define TRACE_E1000E_WRN_NO_TS_SUPPORT_ENABLED 1
#define TRACE_E1000E_WRN_NO_SNAP_SUPPORT_ENABLED 1
#define TRACE_E1000E_WRN_ISCSI_FILTERING_NOT_SUPPORTED_ENABLED 1
#define TRACE_E1000E_WRN_NFSW_FILTERING_NOT_SUPPORTED_ENABLED 1
#define TRACE_E1000E_WRN_NFSR_FILTERING_NOT_SUPPORTED_ENABLED 1
#define TRACE_E1000E_TX_DISABLED_ENABLED 1
#define TRACE_E1000E_TX_DESCR_ENABLED 1
#define TRACE_E1000E_RING_FREE_SPACE_ENABLED 1
#define TRACE_E1000E_RX_CAN_RECV_RINGS_FULL_ENABLED 1
#define TRACE_E1000E_RX_CAN_RECV_ENABLED 1
#define TRACE_E1000E_RX_HAS_BUFFERS_ENABLED 1
#define TRACE_E1000E_RX_NULL_DESCRIPTOR_ENABLED 1
#define TRACE_E1000E_RX_FLT_VLAN_MISMATCH_ENABLED 1
#define TRACE_E1000E_RX_FLT_VLAN_MATCH_ENABLED 1
#define TRACE_E1000E_RX_DESC_PS_READ_ENABLED 1
#define TRACE_E1000E_RX_DESC_PS_WRITE_ENABLED 1
#define TRACE_E1000E_RX_DESC_BUFF_SIZES_ENABLED 1
#define TRACE_E1000E_RX_DESC_LEN_ENABLED 1
#define TRACE_E1000E_RX_DESC_BUFF_WRITE_ENABLED 1
#define TRACE_E1000E_RX_DESCR_ENABLED 1
#define TRACE_E1000E_RX_SET_RCTL_ENABLED 1
#define TRACE_E1000E_RX_RECEIVE_IOV_ENABLED 1
#define TRACE_E1000E_RX_FLT_DROPPED_ENABLED 1
#define TRACE_E1000E_RX_WRITTEN_TO_GUEST_ENABLED 1
#define TRACE_E1000E_RX_NOT_WRITTEN_TO_GUEST_ENABLED 1
#define TRACE_E1000E_RX_INTERRUPT_SET_ENABLED 1
#define TRACE_E1000E_RX_INTERRUPT_DELAYED_ENABLED 1
#define TRACE_E1000E_RX_SET_CSO_ENABLED 1
#define TRACE_E1000E_RX_SET_RDT_ENABLED 1
#define TRACE_E1000E_RX_SET_RFCTL_ENABLED 1
#define TRACE_E1000E_RX_START_RECV_ENABLED 1
#define TRACE_E1000E_RX_RSS_STARTED_ENABLED 1
#define TRACE_E1000E_RX_RSS_DISABLED_ENABLED 1
#define TRACE_E1000E_RX_RSS_TYPE_ENABLED 1
#define TRACE_E1000E_RX_RSS_IP4_ENABLED 1
#define TRACE_E1000E_RX_RSS_IP6_RFCTL_ENABLED 1
#define TRACE_E1000E_RX_RSS_IP6_ENABLED 1
#define TRACE_E1000E_RX_RSS_DISPATCHED_TO_QUEUE_ENABLED 1
#define TRACE_E1000E_RX_METADATA_PROTOCOLS_ENABLED 1
#define TRACE_E1000E_RX_METADATA_VLAN_ENABLED 1
#define TRACE_E1000E_RX_METADATA_RSS_ENABLED 1
#define TRACE_E1000E_RX_METADATA_IP_ID_ENABLED 1
#define TRACE_E1000E_RX_METADATA_ACK_ENABLED 1
#define TRACE_E1000E_RX_METADATA_PKT_TYPE_ENABLED 1
#define TRACE_E1000E_RX_METADATA_NO_VIRTHDR_ENABLED 1
#define TRACE_E1000E_RX_METADATA_VIRTHDR_NO_CSUM_INFO_ENABLED 1
#define TRACE_E1000E_RX_METADATA_L3_CSO_DISABLED_ENABLED 1
#define TRACE_E1000E_RX_METADATA_L4_CSO_DISABLED_ENABLED 1
#define TRACE_E1000E_RX_METADATA_L3_CSUM_VALIDATION_FAILED_ENABLED 1
#define TRACE_E1000E_RX_METADATA_L4_CSUM_VALIDATION_FAILED_ENABLED 1
#define TRACE_E1000E_RX_METADATA_STATUS_FLAGS_ENABLED 1
#define TRACE_E1000E_RX_METADATA_IPV6_SUM_DISABLED_ENABLED 1
#define TRACE_E1000E_RX_METADATA_IPV6_FILTERING_DISABLED_ENABLED 1
#define TRACE_E1000E_VLAN_VET_ENABLED 1
#define TRACE_E1000E_IRQ_MSI_NOTIFY_ENABLED 1
#define TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_INTERRUPTS_ENABLED 1
#define TRACE_E1000E_IRQ_MSI_NOTIFY_POSTPONED_ENABLED 1
#define TRACE_E1000E_IRQ_LEGACY_NOTIFY_POSTPONED_ENABLED 1
#define TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_VEC_ENABLED 1
#define TRACE_E1000E_IRQ_MSIX_NOTIFY_POSTPONED_VEC_ENABLED 1
#define TRACE_E1000E_IRQ_LEGACY_NOTIFY_ENABLED 1
#define TRACE_E1000E_IRQ_MSIX_NOTIFY_VEC_ENABLED 1
#define TRACE_E1000E_IRQ_POSTPONED_BY_XITR_ENABLED 1
#define TRACE_E1000E_IRQ_CLEAR_IMS_ENABLED 1
#define TRACE_E1000E_IRQ_SET_IMS_ENABLED 1
#define TRACE_E1000E_IRQ_FIX_ICR_ASSERTED_ENABLED 1
#define TRACE_E1000E_IRQ_ADD_MSI_OTHER_ENABLED 1
#define TRACE_E1000E_IRQ_PENDING_INTERRUPTS_ENABLED 1
#define TRACE_E1000E_IRQ_SET_CAUSE_ENTRY_ENABLED 1
#define TRACE_E1000E_IRQ_SET_CAUSE_EXIT_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_WRITE_ENABLED 1
#define TRACE_E1000E_IRQ_WRITE_ICS_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_PROCESS_IAME_ENABLED 1
#define TRACE_E1000E_IRQ_READ_ICS_ENABLED 1
#define TRACE_E1000E_IRQ_READ_IMS_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_READ_ENTRY_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_READ_EXIT_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_CLEAR_ZERO_IMS_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_CLEAR_IAME_ENABLED 1
#define TRACE_E1000E_IRQ_IAM_CLEAR_EIAME_ENABLED 1
#define TRACE_E1000E_IRQ_ICR_CLEAR_EIAC_ENABLED 1
#define TRACE_E1000E_IRQ_IMS_CLEAR_SET_IMC_ENABLED 1
#define TRACE_E1000E_IRQ_FIRE_DELAYED_INTERRUPTS_ENABLED 1
#define TRACE_E1000E_IRQ_REARM_TIMER_ENABLED 1
#define TRACE_E1000E_IRQ_THROTTLING_TIMER_ENABLED 1
#define TRACE_E1000E_IRQ_RDTR_FPD_RUNNING_ENABLED 1
#define TRACE_E1000E_IRQ_RDTR_FPD_NOT_RUNNING_ENABLED 1
#define TRACE_E1000E_IRQ_TIDV_FPD_RUNNING_ENABLED 1
#define TRACE_E1000E_IRQ_TIDV_FPD_NOT_RUNNING_ENABLED 1
#define TRACE_E1000E_IRQ_EITR_SET_ENABLED 1
#define TRACE_E1000E_IRQ_ITR_SET_ENABLED 1
#define TRACE_E1000E_IRQ_FIRE_ALL_TIMERS_ENABLED 1
#define TRACE_E1000E_IRQ_ADDING_DELAYED_CAUSES_ENABLED 1
#define TRACE_E1000E_IRQ_MSIX_PENDING_CLEARING_ENABLED 1
#define TRACE_E1000E_WRN_MSIX_VEC_WRONG_ENABLED 1
#define TRACE_E1000E_WRN_MSIX_INVALID_ENABLED 1
#define TRACE_E1000E_MAC_SET_PERMANENT_ENABLED 1
#define TRACE_E1000E_MAC_SET_SW_ENABLED 1
#define TRACE_E1000E_CB_PCI_REALIZE_ENABLED 1
#define TRACE_E1000E_CB_PCI_UNINIT_ENABLED 1
#define TRACE_E1000E_CB_QDEV_RESET_ENABLED 1
#define TRACE_E1000E_CB_PRE_SAVE_ENABLED 1
#define TRACE_E1000E_CB_POST_LOAD_ENABLED 1
#define TRACE_E1000E_IO_WRITE_ADDR_ENABLED 1
#define TRACE_E1000E_IO_WRITE_DATA_ENABLED 1
#define TRACE_E1000E_IO_READ_ADDR_ENABLED 1
#define TRACE_E1000E_IO_READ_DATA_ENABLED 1
#define TRACE_E1000E_WRN_IO_WRITE_UNKNOWN_ENABLED 1
#define TRACE_E1000E_WRN_IO_READ_UNKNOWN_ENABLED 1
#define TRACE_E1000E_WRN_IO_ADDR_UNDEFINED_ENABLED 1
#define TRACE_E1000E_WRN_IO_ADDR_FLASH_ENABLED 1
#define TRACE_E1000E_WRN_IO_ADDR_UNKNOWN_ENABLED 1
#define TRACE_E1000E_MSI_INIT_FAIL_ENABLED 1
#define TRACE_E1000E_MSIX_INIT_FAIL_ENABLED 1
#define TRACE_E1000E_MSIX_USE_VECTOR_FAIL_ENABLED 1
#define TRACE_E1000E_CFG_SUPPORT_VIRTIO_ENABLED 1
#define TRACE_E1000E_VM_STATE_RUNNING_ENABLED 1
#define TRACE_E1000E_VM_STATE_STOPPED_ENABLED 1
#define TRACE_SPAPR_VLAN_GET_RX_BD_FROM_POOL_FOUND_ENABLED 1
#define TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_ENABLED 1
#define TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_FOUND_ENABLED 1
#define TRACE_SPAPR_VLAN_RECEIVE_ENABLED 1
#define TRACE_SPAPR_VLAN_RECEIVE_DMA_COMPLETED_ENABLED 1
#define TRACE_SPAPR_VLAN_RECEIVE_WROTE_ENABLED 1
#define TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_CREATE_ENABLED 1
#define TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_ENABLED 1
#define TRACE_SPAPR_VLAN_ADD_RXBUF_TO_PAGE_ENABLED 1
#define TRACE_SPAPR_VLAN_H_ADD_LOGICAL_LAN_BUFFER_ENABLED 1
#define TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_ENABLED 1
#define TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_RXBUFS_ENABLED 1
#define TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_BUF_DESC_ENABLED 1
#define TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_TOTAL_ENABLED 1
#include "qemu/log.h"


static inline void trace_lance_mem_readw(uint64_t addr, uint32_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_LANCE_MEM_READW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lance_mem_readw " "addr=%"PRIx64"val=0x%04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, ret);
        }
    }
}

static inline void trace_lance_mem_writew(uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_LANCE_MEM_WRITEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lance_mem_writew " "addr=%"PRIx64"val=0x%04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_milkymist_minimac2_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MEMORY_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_memory_read " "addr %08x value %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_milkymist_minimac2_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MEMORY_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_memory_write " "addr %08x value %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_milkymist_minimac2_mdio_write(uint8_t phy_addr, uint8_t addr, uint16_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MDIO_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_mdio_write " "phy_addr %02x addr %02x value %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , phy_addr, addr, value);
        }
    }
}

static inline void trace_milkymist_minimac2_mdio_read(uint8_t phy_addr, uint8_t addr, uint16_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MDIO_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_mdio_read " "phy_addr %02x addr %02x value %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , phy_addr, addr, value);
        }
    }
}

static inline void trace_milkymist_minimac2_tx_frame(uint32_t length)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_TX_FRAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_tx_frame " "length %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , length);
        }
    }
}

static inline void trace_milkymist_minimac2_rx_frame(const void * buf, uint32_t length)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RX_FRAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_rx_frame " "buf %p length %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buf, length);
        }
    }
}

static inline void trace_milkymist_minimac2_rx_transfer(const void * buf, uint32_t length)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RX_TRANSFER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_rx_transfer " "buf %p length %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buf, length);
        }
    }
}

static inline void trace_milkymist_minimac2_raise_irq_rx(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RAISE_IRQ_RX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_raise_irq_rx " "Raise IRQ RX" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_milkymist_minimac2_lower_irq_rx(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_LOWER_IRQ_RX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_lower_irq_rx " "Lower IRQ RX" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_milkymist_minimac2_pulse_irq_tx(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_PULSE_IRQ_TX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_minimac2_pulse_irq_tx " "Pulse IRQ TX" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_mipsnet_send(uint32_t size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MIPSNET_SEND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mipsnet_send " "sending len=%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , size);
        }
    }
}

static inline void trace_mipsnet_receive(uint32_t size)
{
    if (true) {
        if (trace_event_get_state(TRACE_MIPSNET_RECEIVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mipsnet_receive " "receiving len=%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , size);
        }
    }
}

static inline void trace_mipsnet_read(uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MIPSNET_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mipsnet_read " "read addr=0x%" PRIx64 " val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_mipsnet_write(uint64_t addr, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_MIPSNET_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mipsnet_write " "write addr=0x%" PRIx64 " val=0x%" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_mipsnet_irq(uint32_t isr, uint32_t intctl)
{
    if (true) {
        if (trace_event_get_state(TRACE_MIPSNET_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:mipsnet_irq " "set irq to %d (%02x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , isr, intctl);
        }
    }
}

static inline void trace_open_eth_mii_write(unsigned idx, uint16_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_MII_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_mii_write " "MII[%02x] <- %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx, v);
        }
    }
}

static inline void trace_open_eth_mii_read(unsigned idx, uint16_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_MII_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_mii_read " "MII[%02x] -> %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx, v);
        }
    }
}

static inline void trace_open_eth_update_irq(uint32_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_UPDATE_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_update_irq " "IRQ <- %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , v);
        }
    }
}

static inline void trace_open_eth_receive(unsigned len)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_RECEIVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_receive " "RX: len: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , len);
        }
    }
}

static inline void trace_open_eth_receive_mcast(unsigned idx, uint32_t h0, uint32_t h1)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_MCAST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_receive_mcast " "MCAST: idx = %u, hash: %08x:%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx, h0, h1);
        }
    }
}

static inline void trace_open_eth_receive_reject(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_REJECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_receive_reject " "RX: rejected" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_open_eth_receive_desc(uint32_t addr, uint32_t len_flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_DESC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_receive_desc " "RX: %08x, len_flags: %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, len_flags);
        }
    }
}

static inline void trace_open_eth_start_xmit(uint32_t addr, unsigned len, unsigned tx_len)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_START_XMIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_start_xmit " "TX: %08x, len: %u, tx_len: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, len, tx_len);
        }
    }
}

static inline void trace_open_eth_reg_read(uint32_t addr, uint32_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_REG_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_reg_read " "MAC[%02x] -> %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, v);
        }
    }
}

static inline void trace_open_eth_reg_write(uint32_t addr, uint32_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_REG_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_reg_write " "MAC[%02x] <- %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, v);
        }
    }
}

static inline void trace_open_eth_desc_read(uint32_t addr, uint32_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_DESC_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_desc_read " "DESC[%04x] -> %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, v);
        }
    }
}

static inline void trace_open_eth_desc_write(uint32_t addr, uint32_t v)
{
    if (true) {
        if (trace_event_get_state(TRACE_OPEN_ETH_DESC_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:open_eth_desc_write " "DESC[%04x] <- %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, v);
        }
    }
}

static inline void trace_pcnet_s_reset(void * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_S_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_s_reset " "s=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_pcnet_user_int(void * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_USER_INT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_user_int " "s=%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_pcnet_isr_change(void * s, uint32_t isr, uint32_t isr_old)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_ISR_CHANGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_isr_change " "s=%p INTA=%d<=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s, isr, isr_old);
        }
    }
}

static inline void trace_pcnet_init(void * s, uint64_t init_addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_INIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_init " "s=%p init_addr=%#"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s, init_addr);
        }
    }
}

static inline void trace_pcnet_rlen_tlen(void * s, uint32_t rlen, uint32_t tlen)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_RLEN_TLEN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_rlen_tlen " "s=%p rlen=%d tlen=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s, rlen, tlen);
        }
    }
}

static inline void trace_pcnet_ss32_rdra_tdra(void * s, uint32_t ss32, uint32_t rdra, uint32_t rcvrl, uint32_t tdra, uint32_t xmtrl)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_SS32_RDRA_TDRA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_ss32_rdra_tdra " "s=%p ss32=%d rdra=0x%08x[%d] tdra=0x%08x[%d]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s, ss32, rdra, rcvrl, tdra, xmtrl);
        }
    }
}

static inline void trace_pcnet_aprom_writeb(void * opaque, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_APROM_WRITEB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_aprom_writeb " "opaque=%p addr=0x%08x val=0x%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_aprom_readb(void * opaque, uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_APROM_READB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_aprom_readb " "opaque=%p addr=0x%08x val=0x%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_ioport_read(void * opaque, uint64_t addr, unsigned size)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_IOPORT_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_ioport_read " "opaque=%p addr=%#"PRIx64" size=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, size);
        }
    }
}

static inline void trace_pcnet_ioport_write(void * opaque, uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_IOPORT_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_ioport_write " "opaque=%p addr=%#"PRIx64" data=%#"PRIx64" size=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, data, size);
        }
    }
}

static inline void trace_pcnet_mmio_writeb(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_WRITEB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_writeb " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_mmio_writew(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_WRITEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_writew " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_mmio_writel(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_WRITEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_writel " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_mmio_readb(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_READB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_readb " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_mmio_readw(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_READW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_readw " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_pcnet_mmio_readl(void * opaque, uint64_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_PCNET_MMIO_READL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pcnet_mmio_readl " "opaque=%p addr=%#"PRIx64" val=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , opaque, addr, val);
        }
    }
}

static inline void trace_net_rx_pkt_parsed(bool ip4, bool ip6, bool udp, bool tcp, size_t l3o, size_t l4o, size_t l5o)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_PARSED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_parsed " "RX packet parsed: ip4: %d, ip6: %d, udp: %d, tcp: %d, l3 offset: %zu, l4 offset: %zu, l5 offset: %zu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ip4, ip6, udp, tcp, l3o, l4o, l5o);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_validate_entry(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_validate_entry " "Starting L4 checksum validation" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_validate_not_xxp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_NOT_XXP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_validate_not_xxp " "Not a TCP/UDP packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_validate_udp_with_no_checksum(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_UDP_WITH_NO_CHECKSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_validate_udp_with_no_checksum " "UDP packet without checksum" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_validate_ip4_fragment(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_IP4_FRAGMENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_validate_ip4_fragment " "IP4 fragment" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_validate_csum(bool csum_valid)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_VALIDATE_CSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_validate_csum " "Checksum valid: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , csum_valid);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_entry(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_entry " "Starting L4 checksum calculation" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_ip4_udp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_UDP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_ip4_udp " "IP4/UDP packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_ip4_tcp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_IP4_TCP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_ip4_tcp " "IP4/TCP packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_ip6_udp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_UDP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_ip6_udp " "IP6/UDP packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_ip6_tcp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_IP6_TCP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_ip6_tcp " "IP6/TCP packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_ph_csum(uint32_t cntr, uint16_t csl)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_PH_CSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_ph_csum " "Pseudo-header: checksum counter %u, length %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cntr, csl);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_calc_csum(size_t l4hdr_off, uint16_t csl, uint32_t cntr, uint16_t csum)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_CALC_CSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_calc_csum " "L4 Checksum: L4 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , l4hdr_off, csl, cntr, csum);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_entry(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_entry " "Starting L4 checksum correction" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_tcp(uint32_t l4_cso)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_TCP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_tcp " "TCP packet, L4 cso: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , l4_cso);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_udp(uint32_t l4_cso)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_udp " "UDP packet, L4 cso: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , l4_cso);
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_not_xxp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_NOT_XXP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_not_xxp " "Not an IP4 packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_ip4_fragment(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_IP4_FRAGMENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_ip4_fragment " "IP4 fragment" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_udp_with_no_checksum(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_UDP_WITH_NO_CHECKSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_udp_with_no_checksum " "UDP packet without checksum" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l4_csum_fix_csum(uint32_t cso, uint16_t csum)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L4_CSUM_FIX_CSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l4_csum_fix_csum " "L4 Checksum: Offset: %u, value 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cso, csum);
        }
    }
}

static inline void trace_net_rx_pkt_l3_csum_validate_entry(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l3_csum_validate_entry " "Starting L3 checksum validation" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l3_csum_validate_not_ip4(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_NOT_IP4)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l3_csum_validate_not_ip4 " "Not an IP4 packet" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_l3_csum_validate_csum(size_t l3hdr_off, uint32_t csl, uint32_t cntr, uint16_t csum, bool csum_valid)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_L3_CSUM_VALIDATE_CSUM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_l3_csum_validate_csum " "L3 Checksum: L3 header offset: %zu, length: %u, counter: 0x%X, final checksum: 0x%X, valid: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , l3hdr_off, csl, cntr, csum, csum_valid);
        }
    }
}

static inline void trace_net_rx_pkt_rss_ip4(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_IP4)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_ip4 " "Calculating IPv4 RSS  hash" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_rss_ip4_tcp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_IP4_TCP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_ip4_tcp " "Calculating IPv4/TCP RSS  hash" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_rss_ip6_tcp(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_IP6_TCP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_ip6_tcp " "Calculating IPv6/TCP RSS  hash" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_rss_ip6(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_IP6)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_ip6 " "Calculating IPv6 RSS  hash" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_rss_ip6_ex(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_IP6_EX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_ip6_ex " "Calculating IPv6/EX RSS  hash" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_net_rx_pkt_rss_hash(size_t rss_length, uint32_t rss_hash)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_HASH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_hash " "RSS hash for %zu bytes: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rss_length, rss_hash);
        }
    }
}

static inline void trace_net_rx_pkt_rss_add_chunk(void* ptr, size_t size, size_t input_offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_NET_RX_PKT_RSS_ADD_CHUNK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:net_rx_pkt_rss_add_chunk " "Add RSS chunk %p, %zu bytes, RSS input offset %zu bytes" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ptr, size, input_offset);
        }
    }
}

static inline void trace_e1000x_rx_can_recv_disabled(bool link_up, bool rx_enabled, bool pci_master)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_CAN_RECV_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_can_recv_disabled " "link_up: %d, rx_enabled %d, pci_master %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , link_up, rx_enabled, pci_master);
        }
    }
}

static inline void trace_e1000x_vlan_is_vlan_pkt(bool is_vlan_pkt, uint16_t eth_proto, uint16_t vet)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_VLAN_IS_VLAN_PKT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_vlan_is_vlan_pkt " "Is VLAN packet: %d, ETH proto: 0x%X, VET: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , is_vlan_pkt, eth_proto, vet);
        }
    }
}

static inline void trace_e1000x_rx_flt_ucast_match(uint32_t idx, uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_FLT_UCAST_MATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_flt_ucast_match " "unicast match[%d]: %02x:%02x:%02x:%02x:%02x:%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx, b0, b1, b2, b3, b4, b5);
        }
    }
}

static inline void trace_e1000x_rx_flt_ucast_mismatch(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_FLT_UCAST_MISMATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_flt_ucast_mismatch " "unicast mismatch: %02x:%02x:%02x:%02x:%02x:%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3, b4, b5);
        }
    }
}

static inline void trace_e1000x_rx_flt_inexact_mismatch(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5, uint32_t mo, uint32_t mta, uint32_t mta_val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_FLT_INEXACT_MISMATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_flt_inexact_mismatch " "inexact mismatch: %02x:%02x:%02x:%02x:%02x:%02x MO %d MTA[%d] %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3, b4, b5, mo, mta, mta_val);
        }
    }
}

static inline void trace_e1000x_rx_link_down(uint32_t status_reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_LINK_DOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_link_down " "Received packet dropped because the link is down STATUS = %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status_reg);
        }
    }
}

static inline void trace_e1000x_rx_disabled(uint32_t rctl_reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_disabled " "Received packet dropped because receive is disabled RCTL = %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rctl_reg);
        }
    }
}

static inline void trace_e1000x_rx_oversized(size_t size)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_RX_OVERSIZED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_rx_oversized " "Received packet dropped because it was oversized (%zu bytes)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , size);
        }
    }
}

static inline void trace_e1000x_mac_indicate(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_MAC_INDICATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_mac_indicate " "Indicating MAC to guest: %02x:%02x:%02x:%02x:%02x:%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3, b4, b5);
        }
    }
}

static inline void trace_e1000x_link_negotiation_start(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_LINK_NEGOTIATION_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_link_negotiation_start " "Start link auto negotiation" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000x_link_negotiation_done(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000X_LINK_NEGOTIATION_DONE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000x_link_negotiation_done " "Auto negotiation is completed" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_core_write(uint64_t index, uint32_t size, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_write " "Write to register 0x%"PRIx64", %d byte(s), value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, size, val);
        }
    }
}

static inline void trace_e1000e_core_read(uint64_t index, uint32_t size, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_read " "Read from register 0x%"PRIx64", %d byte(s), value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, size, val);
        }
    }
}

static inline void trace_e1000e_core_mdic_read(uint8_t page, uint32_t addr, uint32_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_MDIC_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_mdic_read " "MDIC READ: PHY[%u][%u] = 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , page, addr, data);
        }
    }
}

static inline void trace_e1000e_core_mdic_read_unhandled(uint8_t page, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_MDIC_READ_UNHANDLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_mdic_read_unhandled " "MDIC READ: PHY[%u][%u] UNHANDLED" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , page, addr);
        }
    }
}

static inline void trace_e1000e_core_mdic_write(uint8_t page, uint32_t addr, uint32_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_MDIC_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_mdic_write " "MDIC WRITE: PHY[%u][%u] = 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , page, addr, data);
        }
    }
}

static inline void trace_e1000e_core_mdic_write_unhandled(uint8_t page, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_MDIC_WRITE_UNHANDLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_mdic_write_unhandled " "MDIC WRITE: PHY[%u][%u] UNHANDLED" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , page, addr);
        }
    }
}

static inline void trace_e1000e_core_ctrl_write(uint64_t index, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_CTRL_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_ctrl_write " "Write CTRL register 0x%"PRIx64", value: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, val);
        }
    }
}

static inline void trace_e1000e_core_ctrl_sw_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_CTRL_SW_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_ctrl_sw_reset " "Doing SW reset" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_core_ctrl_phy_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CORE_CTRL_PHY_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_core_ctrl_phy_reset " "Doing PHY reset" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_link_autoneg_flowctl(bool enabled)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_AUTONEG_FLOWCTL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_autoneg_flowctl " "Auto-negotiated flow control state is %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , enabled);
        }
    }
}

static inline void trace_e1000e_link_set_params(bool autodetect, uint32_t speed, bool force_spd, bool force_dplx, bool rx_fctl, bool tx_fctl)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_SET_PARAMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_set_params " "Set link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , autodetect, speed, force_spd, force_dplx, rx_fctl, tx_fctl);
        }
    }
}

static inline void trace_e1000e_link_read_params(bool autodetect, uint32_t speed, bool force_spd, bool force_dplx, bool rx_fctl, bool tx_fctl)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_READ_PARAMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_read_params " "Get link params: Autodetect: %d, Speed: %d, Force speed: %d, Force duplex: %d, RX flow control %d, TX flow control %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , autodetect, speed, force_spd, force_dplx, rx_fctl, tx_fctl);
        }
    }
}

static inline void trace_e1000e_link_set_ext_params(bool asd_check, bool speed_select_bypass)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_SET_EXT_PARAMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_set_ext_params " "Set extended link params: ASD check: %d, Speed select bypass: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , asd_check, speed_select_bypass);
        }
    }
}

static inline void trace_e1000e_link_status(bool link_up, bool full_dplx, uint32_t speed, uint32_t asdv)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_STATUS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_status " "Link up: %d, Duplex: %d, Speed: %d, ASDV: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , link_up, full_dplx, speed, asdv);
        }
    }
}

static inline void trace_e1000e_link_status_changed(bool status)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_LINK_STATUS_CHANGED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_link_status_changed " "New link status: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status);
        }
    }
}

static inline void trace_e1000e_wrn_regs_write_ro(uint64_t index, uint32_t size, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_REGS_WRITE_RO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_regs_write_ro " "WARNING: Write to RO register 0x%"PRIx64", %d byte(s), value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, size, val);
        }
    }
}

static inline void trace_e1000e_wrn_regs_write_unknown(uint64_t index, uint32_t size, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_REGS_WRITE_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_regs_write_unknown " "WARNING: Write to unknown register 0x%"PRIx64", %d byte(s), value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, size, val);
        }
    }
}

static inline void trace_e1000e_wrn_regs_read_unknown(uint64_t index, uint32_t size)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_REGS_READ_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_regs_read_unknown " "WARNING: Read from unknown register 0x%"PRIx64", %d byte(s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, size);
        }
    }
}

static inline void trace_e1000e_wrn_regs_read_trivial(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_REGS_READ_TRIVIAL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_regs_read_trivial " "WARNING: Reading register at offset: 0x%05x. It is not fully implemented." "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_e1000e_wrn_regs_write_trivial(uint32_t index)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_REGS_WRITE_TRIVIAL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_regs_write_trivial " "WARNING: Writing to register at offset: 0x%05x. It is not fully implemented." "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_e1000e_wrn_no_ts_support(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_NO_TS_SUPPORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_no_ts_support " "WARNING: Guest requested TX timestamping which is not supported" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_wrn_no_snap_support(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_NO_SNAP_SUPPORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_no_snap_support " "WARNING: Guest requested TX SNAP header update which is not supported" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_wrn_iscsi_filtering_not_supported(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_ISCSI_FILTERING_NOT_SUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_iscsi_filtering_not_supported " "WARNING: Guest requested iSCSI filtering  which is not supported" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_wrn_nfsw_filtering_not_supported(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_NFSW_FILTERING_NOT_SUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_nfsw_filtering_not_supported " "WARNING: Guest requested NFS write filtering  which is not supported" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_wrn_nfsr_filtering_not_supported(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_NFSR_FILTERING_NOT_SUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_nfsr_filtering_not_supported " "WARNING: Guest requested NFS read filtering  which is not supported" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_tx_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_TX_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_tx_disabled " "TX Disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_tx_descr(void * addr, uint32_t lower, uint32_t upper)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_TX_DESCR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_tx_descr " "%p : %x %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, lower, upper);
        }
    }
}

static inline void trace_e1000e_ring_free_space(int ridx, uint32_t rdlen, uint32_t rdh, uint32_t rdt)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RING_FREE_SPACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_ring_free_space " "ring #%d: LEN: %u, DH: %u, DT: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ridx, rdlen, rdh, rdt);
        }
    }
}

static inline void trace_e1000e_rx_can_recv_rings_full(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_CAN_RECV_RINGS_FULL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_can_recv_rings_full " "Cannot receive: all rings are full" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_can_recv(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_CAN_RECV)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_can_recv " "Can receive" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_has_buffers(int ridx, uint32_t free_desc, size_t total_size, uint32_t desc_buf_size)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_HAS_BUFFERS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_has_buffers " "ring #%d: free descr: %u, packet size %zu, descr buffer size %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ridx, free_desc, total_size, desc_buf_size);
        }
    }
}

static inline void trace_e1000e_rx_null_descriptor(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_NULL_DESCRIPTOR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_null_descriptor " "Null RX descriptor!!" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_flt_vlan_mismatch(uint16_t vid)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_FLT_VLAN_MISMATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_flt_vlan_mismatch " "VID mismatch: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vid);
        }
    }
}

static inline void trace_e1000e_rx_flt_vlan_match(uint16_t vid)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_FLT_VLAN_MATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_flt_vlan_match " "VID match: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vid);
        }
    }
}

static inline void trace_e1000e_rx_desc_ps_read(uint64_t a0, uint64_t a1, uint64_t a2, uint64_t a3)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESC_PS_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_desc_ps_read " "buffers: [0x%"PRIx64", 0x%"PRIx64", 0x%"PRIx64", 0x%"PRIx64"]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , a0, a1, a2, a3);
        }
    }
}

static inline void trace_e1000e_rx_desc_ps_write(uint16_t a0, uint16_t a1, uint16_t a2, uint16_t a3)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESC_PS_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_desc_ps_write " "bytes written: [%u, %u, %u, %u]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , a0, a1, a2, a3);
        }
    }
}

static inline void trace_e1000e_rx_desc_buff_sizes(uint32_t b0, uint32_t b1, uint32_t b2, uint32_t b3)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESC_BUFF_SIZES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_desc_buff_sizes " "buffer sizes: [%u, %u, %u, %u]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3);
        }
    }
}

static inline void trace_e1000e_rx_desc_len(uint8_t rx_desc_len)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESC_LEN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_desc_len " "RX descriptor length: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rx_desc_len);
        }
    }
}

static inline void trace_e1000e_rx_desc_buff_write(uint8_t idx, uint64_t addr, uint16_t offset, const void* source, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESC_BUFF_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_desc_buff_write " "buffer #%u, addr: 0x%"PRIx64", offset: %u, from: %p, length: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx, addr, offset, source, len);
        }
    }
}

static inline void trace_e1000e_rx_descr(int ridx, uint64_t base, uint8_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_DESCR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_descr " "Next RX descriptor: ring #%d, PA: 0x%"PRIx64", length: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ridx, base, len);
        }
    }
}

static inline void trace_e1000e_rx_set_rctl(uint32_t rctl)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_SET_RCTL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_set_rctl " "RCTL = 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rctl);
        }
    }
}

static inline void trace_e1000e_rx_receive_iov(int iovcnt)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RECEIVE_IOV)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_receive_iov " "Received vector of %d fragments" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , iovcnt);
        }
    }
}

static inline void trace_e1000e_rx_flt_dropped(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_FLT_DROPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_flt_dropped " "Received packet dropped by RX filter" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_written_to_guest(uint32_t causes)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_WRITTEN_TO_GUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_written_to_guest " "Received packet written to guest (ICR causes %u)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , causes);
        }
    }
}

static inline void trace_e1000e_rx_not_written_to_guest(uint32_t causes)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_NOT_WRITTEN_TO_GUEST)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_not_written_to_guest " "Received packet NOT written to guest (ICR causes %u)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , causes);
        }
    }
}

static inline void trace_e1000e_rx_interrupt_set(uint32_t causes)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_INTERRUPT_SET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_interrupt_set " "Receive interrupt set (ICR causes %u)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , causes);
        }
    }
}

static inline void trace_e1000e_rx_interrupt_delayed(uint32_t causes)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_INTERRUPT_DELAYED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_interrupt_delayed " "Receive interrupt delayed (ICR causes %u)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , causes);
        }
    }
}

static inline void trace_e1000e_rx_set_cso(int cso_state)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_SET_CSO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_set_cso " "RX CSO state set to %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cso_state);
        }
    }
}

static inline void trace_e1000e_rx_set_rdt(int queue_idx, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_SET_RDT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_set_rdt " "Setting RDT[%d] = %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , queue_idx, val);
        }
    }
}

static inline void trace_e1000e_rx_set_rfctl(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_SET_RFCTL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_set_rfctl " "Setting RFCTL = 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_e1000e_rx_start_recv(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_START_RECV)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_start_recv "  "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_rss_started(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_STARTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_started " "Starting RSS processing" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_rss_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_disabled " "RSS is disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_rss_type(uint32_t type)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_TYPE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_type " "RSS type is %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , type);
        }
    }
}

static inline void trace_e1000e_rx_rss_ip4(bool isfragment, bool istcp, uint32_t mrqc, bool tcpipv4_enabled, bool ipv4_enabled)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_IP4)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_ip4 " "RSS IPv4: fragment %d, tcp %d, mrqc 0x%X, tcpipv4 enabled %d, ipv4 enabled %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , isfragment, istcp, mrqc, tcpipv4_enabled, ipv4_enabled);
        }
    }
}

static inline void trace_e1000e_rx_rss_ip6_rfctl(uint32_t rfctl)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_IP6_RFCTL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_ip6_rfctl " "RSS IPv6: rfctl 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rfctl);
        }
    }
}

static inline void trace_e1000e_rx_rss_ip6(bool ex_dis, bool new_ex_dis, bool istcp, bool has_ext_headers, bool ex_dst_valid, bool ex_src_valid, uint32_t mrqc, bool tcpipv6_enabled, bool ipv6ex_enabled, bool ipv6_enabled)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_IP6)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_ip6 " "RSS IPv6: ex_dis: %d, new_ex_dis: %d, tcp %d, has_ext_headers %d, ex_dst_valid %d, ex_src_valid %d, mrqc 0x%X, tcpipv6 enabled %d, ipv6ex enabled %d, ipv6 enabled %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ex_dis, new_ex_dis, istcp, has_ext_headers, ex_dst_valid, ex_src_valid, mrqc, tcpipv6_enabled, ipv6ex_enabled, ipv6_enabled);
        }
    }
}

static inline void trace_e1000e_rx_rss_dispatched_to_queue(int queue_idx)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_RSS_DISPATCHED_TO_QUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_rss_dispatched_to_queue " "Packet being dispatched to queue %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , queue_idx);
        }
    }
}

static inline void trace_e1000e_rx_metadata_protocols(bool isip4, bool isip6, bool isudp, bool istcp)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_PROTOCOLS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_protocols " "protocols: ip4: %d, ip6: %d, udp: %d, tcp: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , isip4, isip6, isudp, istcp);
        }
    }
}

static inline void trace_e1000e_rx_metadata_vlan(uint16_t vlan_tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_VLAN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_vlan " "VLAN tag is 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vlan_tag);
        }
    }
}

static inline void trace_e1000e_rx_metadata_rss(uint32_t rss, uint32_t mrq)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_RSS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_rss " "RSS data: rss: 0x%X, mrq: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rss, mrq);
        }
    }
}

static inline void trace_e1000e_rx_metadata_ip_id(uint16_t ip_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_IP_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_ip_id " "the IPv4 ID is 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ip_id);
        }
    }
}

static inline void trace_e1000e_rx_metadata_ack(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_ACK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_ack " "the packet is TCP ACK" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_pkt_type(uint32_t pkt_type)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_PKT_TYPE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_pkt_type " "the packet type is %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pkt_type);
        }
    }
}

static inline void trace_e1000e_rx_metadata_no_virthdr(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_NO_VIRTHDR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_no_virthdr " "the packet has no virt-header" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_virthdr_no_csum_info(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_VIRTHDR_NO_CSUM_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_virthdr_no_csum_info " "virt-header does not contain checksum info" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_l3_cso_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_L3_CSO_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_l3_cso_disabled " "IP4 CSO is disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_l4_cso_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_L4_CSO_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_l4_cso_disabled " "TCP/UDP CSO is disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_l3_csum_validation_failed(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_L3_CSUM_VALIDATION_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_l3_csum_validation_failed " "Cannot validate L3 checksum" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_l4_csum_validation_failed(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_L4_CSUM_VALIDATION_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_l4_csum_validation_failed " "Cannot validate L4 checksum" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_status_flags(uint32_t status_flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_STATUS_FLAGS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_status_flags " "status_flags is 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status_flags);
        }
    }
}

static inline void trace_e1000e_rx_metadata_ipv6_sum_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_IPV6_SUM_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_ipv6_sum_disabled " "IPv6 RX checksummimg disabled by RFCTL" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_rx_metadata_ipv6_filtering_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_RX_METADATA_IPV6_FILTERING_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_rx_metadata_ipv6_filtering_disabled " "IPv6 RX filtering disabled by RFCTL" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_vlan_vet(uint16_t vet)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_VLAN_VET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_vlan_vet " "Setting VLAN ethernet type 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vet);
        }
    }
}

static inline void trace_e1000e_irq_msi_notify(uint32_t cause)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_MSI_NOTIFY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_msi_notify " "MSI notify 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cause);
        }
    }
}

static inline void trace_e1000e_irq_throttling_no_pending_interrupts(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_INTERRUPTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_throttling_no_pending_interrupts " "No pending interrupts to notify" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_msi_notify_postponed(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_MSI_NOTIFY_POSTPONED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_msi_notify_postponed " "Sending MSI postponed by ITR" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_legacy_notify_postponed(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_LEGACY_NOTIFY_POSTPONED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_legacy_notify_postponed " "Raising legacy IRQ postponed by ITR" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_throttling_no_pending_vec(int idx)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_THROTTLING_NO_PENDING_VEC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_throttling_no_pending_vec " "No pending interrupts for vector %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx);
        }
    }
}

static inline void trace_e1000e_irq_msix_notify_postponed_vec(int idx)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_MSIX_NOTIFY_POSTPONED_VEC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_msix_notify_postponed_vec " "Sending MSI-X postponed by EITR[%d]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , idx);
        }
    }
}

static inline void trace_e1000e_irq_legacy_notify(bool level)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_LEGACY_NOTIFY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_legacy_notify " "IRQ line state: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , level);
        }
    }
}

static inline void trace_e1000e_irq_msix_notify_vec(uint32_t vector)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_MSIX_NOTIFY_VEC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_msix_notify_vec " "MSI-X notify vector 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector);
        }
    }
}

static inline void trace_e1000e_irq_postponed_by_xitr(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_POSTPONED_BY_XITR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_postponed_by_xitr " "Interrupt postponed by [E]ITR register 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_e1000e_irq_clear_ims(uint32_t bits, uint32_t old_ims, uint32_t new_ims)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_CLEAR_IMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_clear_ims " "Clearing IMS bits 0x%x: 0x%x --> 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bits, old_ims, new_ims);
        }
    }
}

static inline void trace_e1000e_irq_set_ims(uint32_t bits, uint32_t old_ims, uint32_t new_ims)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_SET_IMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_set_ims " "Setting IMS bits 0x%x: 0x%x --> 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bits, old_ims, new_ims);
        }
    }
}

static inline void trace_e1000e_irq_fix_icr_asserted(uint32_t new_val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_FIX_ICR_ASSERTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_fix_icr_asserted " "ICR_ASSERTED bit fixed: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , new_val);
        }
    }
}

static inline void trace_e1000e_irq_add_msi_other(uint32_t new_val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ADD_MSI_OTHER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_add_msi_other " "ICR_OTHER bit added: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , new_val);
        }
    }
}

static inline void trace_e1000e_irq_pending_interrupts(uint32_t pending, uint32_t icr, uint32_t ims)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_PENDING_INTERRUPTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_pending_interrupts " "ICR PENDING: 0x%x (ICR: 0x%x, IMS: 0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pending, icr, ims);
        }
    }
}

static inline void trace_e1000e_irq_set_cause_entry(uint32_t val, uint32_t icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_SET_CAUSE_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_set_cause_entry " "Going to set IRQ cause 0x%x, ICR: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val, icr);
        }
    }
}

static inline void trace_e1000e_irq_set_cause_exit(uint32_t val, uint32_t icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_SET_CAUSE_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_set_cause_exit " "Set IRQ cause 0x%x, ICR: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val, icr);
        }
    }
}

static inline void trace_e1000e_irq_icr_write(uint32_t bits, uint32_t old_icr, uint32_t new_icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_write " "Clearing ICR bits 0x%x: 0x%x --> 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bits, old_icr, new_icr);
        }
    }
}

static inline void trace_e1000e_irq_write_ics(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_WRITE_ICS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_write_ics " "Adding ICR bits 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_e1000e_irq_icr_process_iame(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_PROCESS_IAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_process_iame " "Clearing IMS bits due to IAME" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_read_ics(uint32_t ics)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_READ_ICS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_read_ics " "Current ICS: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ics);
        }
    }
}

static inline void trace_e1000e_irq_read_ims(uint32_t ims)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_READ_IMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_read_ims " "Current IMS: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ims);
        }
    }
}

static inline void trace_e1000e_irq_icr_read_entry(uint32_t icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_READ_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_read_entry " "Starting ICR read. Current ICR: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , icr);
        }
    }
}

static inline void trace_e1000e_irq_icr_read_exit(uint32_t icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_READ_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_read_exit " "Ending ICR read. Current ICR: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , icr);
        }
    }
}

static inline void trace_e1000e_irq_icr_clear_zero_ims(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_CLEAR_ZERO_IMS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_clear_zero_ims " "Clearing ICR on read due to zero IMS" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_icr_clear_iame(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_CLEAR_IAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_clear_iame " "Clearing ICR on read due to IAME" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_iam_clear_eiame(uint32_t iam, uint32_t cause)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_IAM_CLEAR_EIAME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_iam_clear_eiame " "Clearing IMS due to EIAME, IAM: 0x%X, cause: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , iam, cause);
        }
    }
}

static inline void trace_e1000e_irq_icr_clear_eiac(uint32_t icr, uint32_t eiac)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ICR_CLEAR_EIAC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_icr_clear_eiac " "Clearing ICR bits due to EIAC, ICR: 0x%X, EIAC: 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , icr, eiac);
        }
    }
}

static inline void trace_e1000e_irq_ims_clear_set_imc(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_IMS_CLEAR_SET_IMC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_ims_clear_set_imc " "Clearing IMS bits due to IMC write 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_e1000e_irq_fire_delayed_interrupts(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_FIRE_DELAYED_INTERRUPTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_fire_delayed_interrupts " "Firing delayed interrupts" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_rearm_timer(uint32_t reg, int64_t delay_ns)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_REARM_TIMER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_rearm_timer " "Mitigation timer armed for register 0x%X, delay %"PRId64" ns" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, delay_ns);
        }
    }
}

static inline void trace_e1000e_irq_throttling_timer(uint32_t reg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_THROTTLING_TIMER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_throttling_timer " "Mitigation timer shot for register 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg);
        }
    }
}

static inline void trace_e1000e_irq_rdtr_fpd_running(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_RDTR_FPD_RUNNING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_rdtr_fpd_running " "FPD written while RDTR was running" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_rdtr_fpd_not_running(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_RDTR_FPD_NOT_RUNNING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_rdtr_fpd_not_running " "FPD written while RDTR was not running" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_tidv_fpd_running(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_TIDV_FPD_RUNNING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_tidv_fpd_running " "FPD written while TIDV was running" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_tidv_fpd_not_running(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_TIDV_FPD_NOT_RUNNING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_tidv_fpd_not_running " "FPD written while TIDV was not running" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_irq_eitr_set(uint32_t eitr_num, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_EITR_SET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_eitr_set " "EITR[%u] = %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , eitr_num, val);
        }
    }
}

static inline void trace_e1000e_irq_itr_set(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ITR_SET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_itr_set " "ITR = %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_e1000e_irq_fire_all_timers(uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_FIRE_ALL_TIMERS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_fire_all_timers " "Firing all delay/throttling timers on all interrupts enable (0x%X written to IMS)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_e1000e_irq_adding_delayed_causes(uint32_t val, uint32_t icr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_ADDING_DELAYED_CAUSES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_adding_delayed_causes " "Merging delayed causes 0x%X to ICR 0x%X" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val, icr);
        }
    }
}

static inline void trace_e1000e_irq_msix_pending_clearing(uint32_t cause, uint32_t int_cfg, uint32_t vec)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IRQ_MSIX_PENDING_CLEARING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_irq_msix_pending_clearing " "Clearing MSI-X pending bit for cause 0x%x, IVAR config 0x%x, vector %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cause, int_cfg, vec);
        }
    }
}

static inline void trace_e1000e_wrn_msix_vec_wrong(uint32_t cause, uint32_t cfg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_MSIX_VEC_WRONG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_msix_vec_wrong " "Invalid configuration for cause 0x%x: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cause, cfg);
        }
    }
}

static inline void trace_e1000e_wrn_msix_invalid(uint32_t cause, uint32_t cfg)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_MSIX_INVALID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_msix_invalid " "Invalid entry for cause 0x%x: 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cause, cfg);
        }
    }
}

static inline void trace_e1000e_mac_set_permanent(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_MAC_SET_PERMANENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_mac_set_permanent " "Set permanent MAC: %02x:%02x:%02x:%02x:%02x:%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3, b4, b5);
        }
    }
}

static inline void trace_e1000e_mac_set_sw(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3, uint8_t b4, uint8_t b5)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_MAC_SET_SW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_mac_set_sw " "Set SW MAC: %02x:%02x:%02x:%02x:%02x:%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , b0, b1, b2, b3, b4, b5);
        }
    }
}

static inline void trace_e1000e_cb_pci_realize(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CB_PCI_REALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cb_pci_realize " "E1000E PCI realize entry" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_cb_pci_uninit(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CB_PCI_UNINIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cb_pci_uninit " "E1000E PCI unit entry" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_cb_qdev_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CB_QDEV_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cb_qdev_reset " "E1000E qdev reset entry" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_cb_pre_save(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CB_PRE_SAVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cb_pre_save " "E1000E pre save entry" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_cb_post_load(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CB_POST_LOAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cb_post_load " "E1000E post load entry" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_io_write_addr(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IO_WRITE_ADDR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_io_write_addr " "IOADDR write 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_io_write_data(uint64_t addr, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IO_WRITE_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_io_write_data " "IODATA write 0x%"PRIx64", value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_e1000e_io_read_addr(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IO_READ_ADDR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_io_read_addr " "IOADDR read 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_io_read_data(uint64_t addr, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_IO_READ_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_io_read_data " "IODATA read 0x%"PRIx64", value: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_e1000e_wrn_io_write_unknown(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_IO_WRITE_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_io_write_unknown " "IO write unknown address 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_wrn_io_read_unknown(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_IO_READ_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_io_read_unknown " "IO read unknown address 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_wrn_io_addr_undefined(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_IO_ADDR_UNDEFINED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_io_addr_undefined " "IO undefined register 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_wrn_io_addr_flash(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_IO_ADDR_FLASH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_io_addr_flash " "IO flash access (0x%"PRIx64") not implemented" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_wrn_io_addr_unknown(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_WRN_IO_ADDR_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_wrn_io_addr_unknown " "IO unknown register 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_e1000e_msi_init_fail(int32_t res)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_MSI_INIT_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_msi_init_fail " "Failed to initialize MSI, error %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , res);
        }
    }
}

static inline void trace_e1000e_msix_init_fail(int32_t res)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_MSIX_INIT_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_msix_init_fail " "Failed to initialize MSI-X, error %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , res);
        }
    }
}

static inline void trace_e1000e_msix_use_vector_fail(uint32_t vec, int32_t res)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_MSIX_USE_VECTOR_FAIL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_msix_use_vector_fail " "Failed to use MSI-X vector %d, error %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vec, res);
        }
    }
}

static inline void trace_e1000e_cfg_support_virtio(bool support)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_CFG_SUPPORT_VIRTIO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_cfg_support_virtio " "Virtio header supported: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , support);
        }
    }
}

static inline void trace_e1000e_vm_state_running(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_VM_STATE_RUNNING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_vm_state_running " "VM state is running" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_e1000e_vm_state_stopped(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_E1000E_VM_STATE_STOPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:e1000e_vm_state_stopped " "VM state is stopped" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vlan_get_rx_bd_from_pool_found(int pool, int32_t count, uint32_t rx_bufs)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_GET_RX_BD_FROM_POOL_FOUND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_get_rx_bd_from_pool_found " "pool=%d count=%"PRId32" rxbufs=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pool, count, rx_bufs);
        }
    }
}

static inline void trace_spapr_vlan_get_rx_bd_from_page(int buf_ptr, uint64_t bd)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_get_rx_bd_from_page " "use_buf_ptr=%d bd=0x%016"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buf_ptr, bd);
        }
    }
}

static inline void trace_spapr_vlan_get_rx_bd_from_page_found(uint32_t use_buf_ptr, uint32_t rx_bufs)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_GET_RX_BD_FROM_PAGE_FOUND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_get_rx_bd_from_page_found " "ptr=%"PRIu32" rxbufs=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , use_buf_ptr, rx_bufs);
        }
    }
}

static inline void trace_spapr_vlan_receive(const char * id, uint32_t rx_bufs)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_RECEIVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_receive " "[%s] rx_bufs=%"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , id, rx_bufs);
        }
    }
}

static inline void trace_spapr_vlan_receive_dma_completed(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_RECEIVE_DMA_COMPLETED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_receive_dma_completed " "DMA write completed" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_spapr_vlan_receive_wrote(uint64_t ptr, uint64_t hi, uint64_t lo)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_RECEIVE_WROTE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_receive_wrote " "rxq entry (ptr=0x%"PRIx64"): 0x%016"PRIx64" 0x%016"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ptr, hi, lo);
        }
    }
}

static inline void trace_spapr_vlan_add_rxbuf_to_pool_create(int pool, uint64_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL_CREATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_add_rxbuf_to_pool_create " "created RX pool %d for size %"PRIu64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pool, len);
        }
    }
}

static inline void trace_spapr_vlan_add_rxbuf_to_pool(int pool, uint64_t len, int32_t count)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_ADD_RXBUF_TO_POOL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_add_rxbuf_to_pool " "add buf using pool %d (size %"PRIu64", count=%"PRId32")" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pool, len, count);
        }
    }
}

static inline void trace_spapr_vlan_add_rxbuf_to_page(uint32_t ptr, uint32_t rx_bufs, uint64_t bd)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_ADD_RXBUF_TO_PAGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_add_rxbuf_to_page " "added buf ptr=%"PRIu32"  rx_bufs=%"PRIu32" bd=0x%016"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ptr, rx_bufs, bd);
        }
    }
}

static inline void trace_spapr_vlan_h_add_logical_lan_buffer(uint64_t reg, uint64_t buf)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_H_ADD_LOGICAL_LAN_BUFFER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_h_add_logical_lan_buffer " "H_ADD_LOGICAL_LAN_BUFFER(0x%"PRIx64", 0x%"PRIx64")" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, buf);
        }
    }
}

static inline void trace_spapr_vlan_h_send_logical_lan(uint64_t reg, uint64_t continue_token)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_h_send_logical_lan " "H_SEND_LOGICAL_LAN(0x%"PRIx64", <bufs>, 0x%"PRIx64")" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reg, continue_token);
        }
    }
}

static inline void trace_spapr_vlan_h_send_logical_lan_rxbufs(uint32_t rx_bufs)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_RXBUFS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_h_send_logical_lan_rxbufs " "rxbufs = %"PRIu32 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rx_bufs);
        }
    }
}

static inline void trace_spapr_vlan_h_send_logical_lan_buf_desc(uint64_t buf)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_BUF_DESC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_h_send_logical_lan_buf_desc " "   buf desc: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , buf);
        }
    }
}

static inline void trace_spapr_vlan_h_send_logical_lan_total(int nbufs, unsigned total_len)
{
    if (true) {
        if (trace_event_get_state(TRACE_SPAPR_VLAN_H_SEND_LOGICAL_LAN_TOTAL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:spapr_vlan_h_send_logical_lan_total " "%d buffers, total length 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nbufs, total_len);
        }
    }
}
#endif /* TRACE_HW_NET_GENERATED_TRACERS_H */
