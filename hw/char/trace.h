/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_CHAR_GENERATED_TRACERS_H
#define TRACE_HW_CHAR_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_CONSOLE_CHR_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_EVENT_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GRLIB_APBUART_READL_UNKNOWN_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JTX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_GET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_JUART_SET_JRX_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_LM32_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_LM32_UART_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_READ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_MEMORY_WRITE_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_RAISE_IRQ_EVENT;
extern TraceEvent _TRACE_MILKYMIST_UART_LOWER_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_PUT_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_GET_QUEUE_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_ESCC_UPDATE_PARAMETERS_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_WRITEB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_CTRL_EVENT;
extern TraceEvent _TRACE_ESCC_MEM_READB_DATA_EVENT;
extern TraceEvent _TRACE_ESCC_SERIAL_RECEIVE_BYTE_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_IN_EVENT;
extern TraceEvent _TRACE_ESCC_SUNKBD_EVENT_OUT_EVENT;
extern TraceEvent _TRACE_ESCC_KBD_COMMAND_EVENT;
extern TraceEvent _TRACE_ESCC_SUNMOUSE_EVENT_EVENT;
extern TraceEvent _TRACE_PL011_IRQ_STATE_EVENT;
extern TraceEvent _TRACE_PL011_READ_EVENT;
extern TraceEvent _TRACE_PL011_READ_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_WRITE_EVENT;
extern TraceEvent _TRACE_PL011_CAN_RECEIVE_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_EVENT;
extern TraceEvent _TRACE_PL011_PUT_FIFO_FULL_EVENT;
extern uint16_t _TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_THROTTLE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_FLUSH_BUF_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_CONSOLE_CHR_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_EVENT_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GRLIB_APBUART_READL_UNKNOWN_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JTX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_GET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_JUART_SET_JRX_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_LM32_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_LM32_UART_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_READ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_MEMORY_WRITE_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_RAISE_IRQ_DSTATE;
extern uint16_t _TRACE_MILKYMIST_UART_LOWER_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_PUT_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_GET_QUEUE_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_ESCC_UPDATE_PARAMETERS_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_WRITEB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_CTRL_DSTATE;
extern uint16_t _TRACE_ESCC_MEM_READB_DATA_DSTATE;
extern uint16_t _TRACE_ESCC_SERIAL_RECEIVE_BYTE_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_IN_DSTATE;
extern uint16_t _TRACE_ESCC_SUNKBD_EVENT_OUT_DSTATE;
extern uint16_t _TRACE_ESCC_KBD_COMMAND_DSTATE;
extern uint16_t _TRACE_ESCC_SUNMOUSE_EVENT_DSTATE;
extern uint16_t _TRACE_PL011_IRQ_STATE_DSTATE;
extern uint16_t _TRACE_PL011_READ_DSTATE;
extern uint16_t _TRACE_PL011_READ_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_WRITE_DSTATE;
extern uint16_t _TRACE_PL011_CAN_RECEIVE_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_DSTATE;
extern uint16_t _TRACE_PL011_PUT_FIFO_FULL_DSTATE;
#define TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_THROTTLE_PORT_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_ENABLED 1
#define TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_FLUSH_BUF_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_READ_ENABLED 1
#define TRACE_VIRTIO_CONSOLE_CHR_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_EVENT_ENABLED 1
#define TRACE_GRLIB_APBUART_WRITEL_UNKNOWN_ENABLED 1
#define TRACE_GRLIB_APBUART_READL_UNKNOWN_ENABLED 1
#define TRACE_LM32_JUART_GET_JTX_ENABLED 1
#define TRACE_LM32_JUART_SET_JTX_ENABLED 1
#define TRACE_LM32_JUART_GET_JRX_ENABLED 1
#define TRACE_LM32_JUART_SET_JRX_ENABLED 1
#define TRACE_LM32_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_LM32_UART_MEMORY_READ_ENABLED 1
#define TRACE_LM32_UART_IRQ_STATE_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_READ_ENABLED 1
#define TRACE_MILKYMIST_UART_MEMORY_WRITE_ENABLED 1
#define TRACE_MILKYMIST_UART_RAISE_IRQ_ENABLED 1
#define TRACE_MILKYMIST_UART_LOWER_IRQ_ENABLED 1
#define TRACE_ESCC_PUT_QUEUE_ENABLED 1
#define TRACE_ESCC_GET_QUEUE_ENABLED 1
#define TRACE_ESCC_UPDATE_IRQ_ENABLED 1
#define TRACE_ESCC_UPDATE_PARAMETERS_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_WRITEB_DATA_ENABLED 1
#define TRACE_ESCC_MEM_READB_CTRL_ENABLED 1
#define TRACE_ESCC_MEM_READB_DATA_ENABLED 1
#define TRACE_ESCC_SERIAL_RECEIVE_BYTE_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_IN_ENABLED 1
#define TRACE_ESCC_SUNKBD_EVENT_OUT_ENABLED 1
#define TRACE_ESCC_KBD_COMMAND_ENABLED 1
#define TRACE_ESCC_SUNMOUSE_EVENT_ENABLED 1
#define TRACE_PL011_IRQ_STATE_ENABLED 1
#define TRACE_PL011_READ_ENABLED 1
#define TRACE_PL011_READ_FIFO_ENABLED 1
#define TRACE_PL011_WRITE_ENABLED 1
#define TRACE_PL011_CAN_RECEIVE_ENABLED 1
#define TRACE_PL011_PUT_FIFO_ENABLED 1
#define TRACE_PL011_PUT_FIFO_FULL_ENABLED 1
#include "qemu/log.h"


static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_serial_send_control_event " "port %u, event %u, value %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, event, value);
        }
    }
}

static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_serial_throttle_port " "port %u, throttle %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, throttle);
        }
    }
}

static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_serial_handle_control_message " "event %u, value %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , event, value);
        }
    }
}

static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_serial_handle_control_message_port " "port %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port);
        }
    }
}

static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, len, ret);
        }
    }
}

static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_console_chr_read " "port %u, size %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, size);
        }
    }
}

static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    if (true) {
        if (trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:virtio_console_chr_event " "port %u, event %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, event);
        }
    }
}

static inline void trace_grlib_apbuart_event(int event)
{
    if (true) {
        if (trace_event_get_state(TRACE_GRLIB_APBUART_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:grlib_apbuart_event " "event:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , event);
        }
    }
}

static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:grlib_apbuart_readl_unknown " "addr 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_lm32_juart_get_jtx(uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_JUART_GET_JTX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_juart_get_jtx " "jtx 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , value);
        }
    }
}

static inline void trace_lm32_juart_set_jtx(uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_JUART_SET_JTX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_juart_set_jtx " "jtx 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , value);
        }
    }
}

static inline void trace_lm32_juart_get_jrx(uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_JUART_GET_JRX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_juart_get_jrx " "jrx 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , value);
        }
    }
}

static inline void trace_lm32_juart_set_jrx(uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_JUART_SET_JRX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_juart_set_jrx " "jrx 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , value);
        }
    }
}

static inline void trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_UART_MEMORY_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_uart_memory_write " "addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_UART_MEMORY_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_uart_memory_read " "addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_lm32_uart_irq_state(int level)
{
    if (true) {
        if (trace_event_get_state(TRACE_LM32_UART_IRQ_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:lm32_uart_irq_state " "irq state %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , level);
        }
    }
}

static inline void trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_uart_memory_read " "addr %08x value %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_uart_memory_write " "addr %08x value %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_milkymist_uart_raise_irq(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_UART_RAISE_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_uart_raise_irq " "Raise IRQ" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_milkymist_uart_lower_irq(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_MILKYMIST_UART_LOWER_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:milkymist_uart_lower_irq " "Lower IRQ" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_escc_put_queue(char channel, int b)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_PUT_QUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_put_queue " "channel %c put: 0x%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, b);
        }
    }
}

static inline void trace_escc_get_queue(char channel, int val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_GET_QUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_get_queue " "channel %c get 0x%02x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, val);
        }
    }
}

static inline void trace_escc_update_irq(int irq)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_UPDATE_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_update_irq " "IRQ = %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , irq);
        }
    }
}

static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, speed, parity, data_bits, stop_bits);
        }
    }
}

static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = %2.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, reg, val);
        }
    }
}

static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_mem_writeb_data " "Write channel %c, ch %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, val);
        }
    }
}

static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_mem_readb_ctrl " "Read channel %c, reg[%d] = %2.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, reg, val);
        }
    }
}

static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_MEM_READB_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_mem_readb_data " "Read channel %c, ch %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, ret);
        }
    }
}

static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_serial_receive_byte " "channel %c put ch %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , channel, ch);
        }
    }
}

static inline void trace_escc_sunkbd_event_in(int ch, const char * name, int down)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_sunkbd_event_in " "QKeyCode 0x%2.2x [%s], down %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ch, name, down);
        }
    }
}

static inline void trace_escc_sunkbd_event_out(int ch)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_sunkbd_event_out " "Translated keycode 0x%2.2x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ch);
        }
    }
}

static inline void trace_escc_kbd_command(int val)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_KBD_COMMAND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_kbd_command " "Command %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , val);
        }
    }
}

static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    if (true) {
        if (trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:escc_sunmouse_event " "dx=%d dy=%d buttons=%01x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dx, dy, buttons_state);
        }
    }
}

static inline void trace_pl011_irq_state(int level)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_IRQ_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_irq_state " "irq state %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , level);
        }
    }
}

static inline void trace_pl011_read(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_read " "addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_pl011_read_fifo(int read_count)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_READ_FIFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_read_fifo " "FIFO read, read_count now %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , read_count);
        }
    }
}

static inline void trace_pl011_write(uint32_t addr, uint32_t value)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_write " "addr 0x%08x value 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, value);
        }
    }
}

static inline void trace_pl011_can_receive(uint32_t lcr, int read_count, int r)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_CAN_RECEIVE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_can_receive " "LCR %08x read_count %d returning %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , lcr, read_count, r);
        }
    }
}

static inline void trace_pl011_put_fifo(uint32_t c, int read_count)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_PUT_FIFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_put_fifo " "new char 0x%x read_count now %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , c, read_count);
        }
    }
}

static inline void trace_pl011_put_fifo_full(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_PL011_PUT_FIFO_FULL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:pl011_put_fifo_full " "FIFO now full, RXFF set" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}
#endif /* TRACE_HW_CHAR_GENERATED_TRACERS_H */
