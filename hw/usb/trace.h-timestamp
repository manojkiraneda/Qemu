/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_USB_GENERATED_TRACERS_H
#define TRACE_HW_USB_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_USB_PACKET_STATE_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_PACKET_STATE_FAULT_EVENT;
extern TraceEvent _TRACE_USB_PORT_CLAIM_EVENT;
extern TraceEvent _TRACE_USB_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_PORT_RELEASE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_READ_FAILED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_HEAD_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_SO_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_NAK_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_SUSPEND_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_REMOTE_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_START_EVENT;
extern TraceEvent _TRACE_USB_OHCI_RESUME_EVENT;
extern TraceEvent _TRACE_USB_OHCI_STOP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_SET_CTL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_UNDERRUN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_DEV_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_NAK_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_STALL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BABBLE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_BAD_DIRECTION_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_SKIP_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_HDR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_SHORT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PKT_FULL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_TOO_MANY_PENDING_EVENT;
extern TraceEvent _TRACE_USB_OHCI_TD_PACKET_STATUS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_PKT_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ED_PKT_FLAGS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HCCA_READ_ERROR_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_READ_UNALIGNED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_EVENT;
extern TraceEvent _TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_EVENT;
extern TraceEvent _TRACE_USB_OHCI_PROCESS_LISTS_EVENT;
extern TraceEvent _TRACE_USB_OHCI_SET_FRAME_INTERVAL_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HUB_POWER_UP_EVENT;
extern TraceEvent _TRACE_USB_OHCI_HUB_POWER_DOWN_EVENT;
extern TraceEvent _TRACE_USB_OHCI_INIT_TIME_EVENT;
extern TraceEvent _TRACE_USB_OHCI_DIE_EVENT;
extern TraceEvent _TRACE_USB_OHCI_ASYNC_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_EHCI_UNREALIZE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_READ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_WRITE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_OPREG_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_READ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_WRITE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORTSC_CHANGE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_USBSTS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_STATE_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_PTRS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_FIELDS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QH_BITS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_PTRS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_FIELDS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QTD_BITS_EVENT;
extern TraceEvent _TRACE_USB_EHCI_ITD_EVENT;
extern TraceEvent _TRACE_USB_EHCI_SITD_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_DETACH_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_SUSPEND_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_WAKEUP_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PORT_RESUME_EVENT;
extern TraceEvent _TRACE_USB_EHCI_QUEUE_ACTION_EVENT;
extern TraceEvent _TRACE_USB_EHCI_PACKET_ACTION_EVENT;
extern TraceEvent _TRACE_USB_EHCI_IRQ_EVENT;
extern TraceEvent _TRACE_USB_EHCI_GUEST_BUG_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DOORBELL_RING_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DOORBELL_ACK_EVENT;
extern TraceEvent _TRACE_USB_EHCI_DMA_ERROR_EVENT;
extern TraceEvent _TRACE_USB_UHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_UHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_UHCI_SCHEDULE_START_EVENT;
extern TraceEvent _TRACE_USB_UHCI_SCHEDULE_STOP_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_START_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_MMIO_READW_EVENT;
extern TraceEvent _TRACE_USB_UHCI_MMIO_WRITEW_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QUEUE_ADD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QUEUE_DEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_ADD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_LINK_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_CANCEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_STALL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_EVENT;
extern TraceEvent _TRACE_USB_UHCI_PACKET_DEL_EVENT;
extern TraceEvent _TRACE_USB_UHCI_QH_LOAD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_LOAD_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_QUEUE_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_NEXTQH_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_UHCI_TD_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EXIT_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUN_EVENT;
extern TraceEvent _TRACE_USB_XHCI_STOP_EVENT;
extern TraceEvent _TRACE_USB_XHCI_CAP_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_OPER_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUNTIME_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_DOORBELL_READ_EVENT;
extern TraceEvent _TRACE_USB_XHCI_OPER_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_RUNTIME_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_DOORBELL_WRITE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_INTX_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_USE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_IRQ_MSIX_UNUSE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_QUEUE_EVENT_EVENT;
extern TraceEvent _TRACE_USB_XHCI_FETCH_TRB_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_LINK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_PORT_NOTIFY_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_ENABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_DISABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_ADDRESS_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_CONFIGURE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_EVALUATE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_SLOT_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_ENABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_DISABLE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_SET_DEQUEUE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_KICK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_STOP_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_RESET_EVENT;
extern TraceEvent _TRACE_USB_XHCI_EP_STATE_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_START_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_ASYNC_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_NAK_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_RETRY_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_XHCI_XFER_ERROR_EVENT;
extern TraceEvent _TRACE_USB_XHCI_UNIMPLEMENTED_EVENT;
extern TraceEvent _TRACE_USB_XHCI_ENFORCED_LIMIT_EVENT;
extern TraceEvent _TRACE_USB_DESC_DEVICE_EVENT;
extern TraceEvent _TRACE_USB_DESC_DEVICE_QUALIFIER_EVENT;
extern TraceEvent _TRACE_USB_DESC_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_DESC_OTHER_SPEED_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_DESC_STRING_EVENT;
extern TraceEvent _TRACE_USB_DESC_BOS_EVENT;
extern TraceEvent _TRACE_USB_DESC_MSOS_EVENT;
extern TraceEvent _TRACE_USB_SET_ADDR_EVENT;
extern TraceEvent _TRACE_USB_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_SET_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_CLEAR_DEVICE_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_SET_DEVICE_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_RESET_EVENT;
extern TraceEvent _TRACE_USB_HUB_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_HUB_GET_PORT_STATUS_EVENT;
extern TraceEvent _TRACE_USB_HUB_SET_PORT_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_CLEAR_PORT_FEATURE_EVENT;
extern TraceEvent _TRACE_USB_HUB_ATTACH_EVENT;
extern TraceEvent _TRACE_USB_HUB_DETACH_EVENT;
extern TraceEvent _TRACE_USB_HUB_STATUS_REPORT_EVENT;
extern TraceEvent _TRACE_USB_UAS_RESET_EVENT;
extern TraceEvent _TRACE_USB_UAS_COMMAND_EVENT;
extern TraceEvent _TRACE_USB_UAS_RESPONSE_EVENT;
extern TraceEvent _TRACE_USB_UAS_SENSE_EVENT;
extern TraceEvent _TRACE_USB_UAS_READ_READY_EVENT;
extern TraceEvent _TRACE_USB_UAS_WRITE_READY_EVENT;
extern TraceEvent _TRACE_USB_UAS_XFER_DATA_EVENT;
extern TraceEvent _TRACE_USB_UAS_SCSI_DATA_EVENT;
extern TraceEvent _TRACE_USB_UAS_SCSI_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_ABORT_TASK_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_EVENT;
extern TraceEvent _TRACE_USB_UAS_TMF_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_USB_MTP_RESET_EVENT;
extern TraceEvent _TRACE_USB_MTP_COMMAND_EVENT;
extern TraceEvent _TRACE_USB_MTP_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_MTP_ERROR_EVENT;
extern TraceEvent _TRACE_USB_MTP_DATA_IN_EVENT;
extern TraceEvent _TRACE_USB_MTP_XFER_EVENT;
extern TraceEvent _TRACE_USB_MTP_NAK_EVENT;
extern TraceEvent _TRACE_USB_MTP_STALL_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_OPEN_SESSION_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_CLOSE_SESSION_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_STORAGE_IDS_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_STORAGE_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_NUM_OBJECTS_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_INFO_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_OBJECT_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_EVENT;
extern TraceEvent _TRACE_USB_MTP_OP_UNKNOWN_EVENT;
extern TraceEvent _TRACE_USB_MTP_OBJECT_ALLOC_EVENT;
extern TraceEvent _TRACE_USB_MTP_OBJECT_FREE_EVENT;
extern TraceEvent _TRACE_USB_MTP_ADD_CHILD_EVENT;
extern TraceEvent _TRACE_USB_MTP_INOTIFY_EVENT_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_STARTED_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_SUCCESS_EVENT;
extern TraceEvent _TRACE_USB_HOST_OPEN_FAILURE_EVENT;
extern TraceEvent _TRACE_USB_HOST_CLOSE_EVENT;
extern TraceEvent _TRACE_USB_HOST_ATTACH_KERNEL_EVENT;
extern TraceEvent _TRACE_USB_HOST_DETACH_KERNEL_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_ADDRESS_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_HOST_SET_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_CLAIM_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_RELEASE_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_CONTROL_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_DATA_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_EMULATED_EVENT;
extern TraceEvent _TRACE_USB_HOST_REQ_CANCELED_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_START_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_STOP_EVENT;
extern TraceEvent _TRACE_USB_HOST_ISO_OUT_OF_BUFS_EVENT;
extern TraceEvent _TRACE_USB_HOST_RESET_EVENT;
extern TraceEvent _TRACE_USB_HOST_AUTO_SCAN_ENABLED_EVENT;
extern TraceEvent _TRACE_USB_HOST_AUTO_SCAN_DISABLED_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_CONFIG_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_INTERFACE_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_ENDPOINT_EVENT;
extern TraceEvent _TRACE_USB_HOST_PARSE_ERROR_EVENT;
extern uint16_t _TRACE_USB_PACKET_STATE_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_PACKET_STATE_FAULT_DSTATE;
extern uint16_t _TRACE_USB_PORT_CLAIM_DSTATE;
extern uint16_t _TRACE_USB_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_PORT_RELEASE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_READ_FAILED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_HEAD_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_SO_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_NAK_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_SUSPEND_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_REMOTE_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_START_DSTATE;
extern uint16_t _TRACE_USB_OHCI_RESUME_DSTATE;
extern uint16_t _TRACE_USB_OHCI_STOP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_SET_CTL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_UNDERRUN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_DEV_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_NAK_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_STALL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BABBLE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_BAD_DIRECTION_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_SKIP_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_HDR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_SHORT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PKT_FULL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_TOO_MANY_PENDING_DSTATE;
extern uint16_t _TRACE_USB_OHCI_TD_PACKET_STATUS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_PKT_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ED_PKT_FLAGS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HCCA_READ_ERROR_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_READ_UNALIGNED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_DSTATE;
extern uint16_t _TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_DSTATE;
extern uint16_t _TRACE_USB_OHCI_PROCESS_LISTS_DSTATE;
extern uint16_t _TRACE_USB_OHCI_SET_FRAME_INTERVAL_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HUB_POWER_UP_DSTATE;
extern uint16_t _TRACE_USB_OHCI_HUB_POWER_DOWN_DSTATE;
extern uint16_t _TRACE_USB_OHCI_INIT_TIME_DSTATE;
extern uint16_t _TRACE_USB_OHCI_DIE_DSTATE;
extern uint16_t _TRACE_USB_OHCI_ASYNC_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_EHCI_UNREALIZE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_READ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_WRITE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_OPREG_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_READ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_WRITE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORTSC_CHANGE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_USBSTS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_STATE_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_PTRS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_FIELDS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QH_BITS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_PTRS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_FIELDS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QTD_BITS_DSTATE;
extern uint16_t _TRACE_USB_EHCI_ITD_DSTATE;
extern uint16_t _TRACE_USB_EHCI_SITD_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_DETACH_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_SUSPEND_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_WAKEUP_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PORT_RESUME_DSTATE;
extern uint16_t _TRACE_USB_EHCI_QUEUE_ACTION_DSTATE;
extern uint16_t _TRACE_USB_EHCI_PACKET_ACTION_DSTATE;
extern uint16_t _TRACE_USB_EHCI_IRQ_DSTATE;
extern uint16_t _TRACE_USB_EHCI_GUEST_BUG_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DOORBELL_RING_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DOORBELL_ACK_DSTATE;
extern uint16_t _TRACE_USB_EHCI_DMA_ERROR_DSTATE;
extern uint16_t _TRACE_USB_UHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_UHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_UHCI_SCHEDULE_START_DSTATE;
extern uint16_t _TRACE_USB_UHCI_SCHEDULE_STOP_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_START_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_MMIO_READW_DSTATE;
extern uint16_t _TRACE_USB_UHCI_MMIO_WRITEW_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QUEUE_ADD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QUEUE_DEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_ADD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_LINK_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_CANCEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_STALL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_DSTATE;
extern uint16_t _TRACE_USB_UHCI_PACKET_DEL_DSTATE;
extern uint16_t _TRACE_USB_UHCI_QH_LOAD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_LOAD_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_QUEUE_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_NEXTQH_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_UHCI_TD_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EXIT_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUN_DSTATE;
extern uint16_t _TRACE_USB_XHCI_STOP_DSTATE;
extern uint16_t _TRACE_USB_XHCI_CAP_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_OPER_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUNTIME_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_DOORBELL_READ_DSTATE;
extern uint16_t _TRACE_USB_XHCI_OPER_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_RUNTIME_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_DOORBELL_WRITE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_INTX_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_USE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_IRQ_MSIX_UNUSE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_QUEUE_EVENT_DSTATE;
extern uint16_t _TRACE_USB_XHCI_FETCH_TRB_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_LINK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_PORT_NOTIFY_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_ENABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_DISABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_ADDRESS_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_CONFIGURE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_EVALUATE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_SLOT_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_ENABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_DISABLE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_SET_DEQUEUE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_KICK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_STOP_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_RESET_DSTATE;
extern uint16_t _TRACE_USB_XHCI_EP_STATE_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_START_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_ASYNC_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_NAK_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_RETRY_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_XHCI_XFER_ERROR_DSTATE;
extern uint16_t _TRACE_USB_XHCI_UNIMPLEMENTED_DSTATE;
extern uint16_t _TRACE_USB_XHCI_ENFORCED_LIMIT_DSTATE;
extern uint16_t _TRACE_USB_DESC_DEVICE_DSTATE;
extern uint16_t _TRACE_USB_DESC_DEVICE_QUALIFIER_DSTATE;
extern uint16_t _TRACE_USB_DESC_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_DESC_OTHER_SPEED_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_DESC_STRING_DSTATE;
extern uint16_t _TRACE_USB_DESC_BOS_DSTATE;
extern uint16_t _TRACE_USB_DESC_MSOS_DSTATE;
extern uint16_t _TRACE_USB_SET_ADDR_DSTATE;
extern uint16_t _TRACE_USB_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_SET_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_CLEAR_DEVICE_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_SET_DEVICE_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_RESET_DSTATE;
extern uint16_t _TRACE_USB_HUB_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_HUB_GET_PORT_STATUS_DSTATE;
extern uint16_t _TRACE_USB_HUB_SET_PORT_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_CLEAR_PORT_FEATURE_DSTATE;
extern uint16_t _TRACE_USB_HUB_ATTACH_DSTATE;
extern uint16_t _TRACE_USB_HUB_DETACH_DSTATE;
extern uint16_t _TRACE_USB_HUB_STATUS_REPORT_DSTATE;
extern uint16_t _TRACE_USB_UAS_RESET_DSTATE;
extern uint16_t _TRACE_USB_UAS_COMMAND_DSTATE;
extern uint16_t _TRACE_USB_UAS_RESPONSE_DSTATE;
extern uint16_t _TRACE_USB_UAS_SENSE_DSTATE;
extern uint16_t _TRACE_USB_UAS_READ_READY_DSTATE;
extern uint16_t _TRACE_USB_UAS_WRITE_READY_DSTATE;
extern uint16_t _TRACE_USB_UAS_XFER_DATA_DSTATE;
extern uint16_t _TRACE_USB_UAS_SCSI_DATA_DSTATE;
extern uint16_t _TRACE_USB_UAS_SCSI_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_ABORT_TASK_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_DSTATE;
extern uint16_t _TRACE_USB_UAS_TMF_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_USB_MTP_RESET_DSTATE;
extern uint16_t _TRACE_USB_MTP_COMMAND_DSTATE;
extern uint16_t _TRACE_USB_MTP_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_MTP_ERROR_DSTATE;
extern uint16_t _TRACE_USB_MTP_DATA_IN_DSTATE;
extern uint16_t _TRACE_USB_MTP_XFER_DSTATE;
extern uint16_t _TRACE_USB_MTP_NAK_DSTATE;
extern uint16_t _TRACE_USB_MTP_STALL_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_OPEN_SESSION_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_CLOSE_SESSION_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_STORAGE_IDS_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_STORAGE_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_NUM_OBJECTS_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_INFO_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_OBJECT_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_DSTATE;
extern uint16_t _TRACE_USB_MTP_OP_UNKNOWN_DSTATE;
extern uint16_t _TRACE_USB_MTP_OBJECT_ALLOC_DSTATE;
extern uint16_t _TRACE_USB_MTP_OBJECT_FREE_DSTATE;
extern uint16_t _TRACE_USB_MTP_ADD_CHILD_DSTATE;
extern uint16_t _TRACE_USB_MTP_INOTIFY_EVENT_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_STARTED_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_SUCCESS_DSTATE;
extern uint16_t _TRACE_USB_HOST_OPEN_FAILURE_DSTATE;
extern uint16_t _TRACE_USB_HOST_CLOSE_DSTATE;
extern uint16_t _TRACE_USB_HOST_ATTACH_KERNEL_DSTATE;
extern uint16_t _TRACE_USB_HOST_DETACH_KERNEL_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_ADDRESS_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_HOST_SET_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_CLAIM_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_RELEASE_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_CONTROL_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_DATA_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_EMULATED_DSTATE;
extern uint16_t _TRACE_USB_HOST_REQ_CANCELED_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_START_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_STOP_DSTATE;
extern uint16_t _TRACE_USB_HOST_ISO_OUT_OF_BUFS_DSTATE;
extern uint16_t _TRACE_USB_HOST_RESET_DSTATE;
extern uint16_t _TRACE_USB_HOST_AUTO_SCAN_ENABLED_DSTATE;
extern uint16_t _TRACE_USB_HOST_AUTO_SCAN_DISABLED_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_CONFIG_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_INTERFACE_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_ENDPOINT_DSTATE;
extern uint16_t _TRACE_USB_HOST_PARSE_ERROR_DSTATE;
#define TRACE_USB_PACKET_STATE_CHANGE_ENABLED 1
#define TRACE_USB_PACKET_STATE_FAULT_ENABLED 1
#define TRACE_USB_PORT_CLAIM_ENABLED 1
#define TRACE_USB_PORT_ATTACH_ENABLED 1
#define TRACE_USB_PORT_DETACH_ENABLED 1
#define TRACE_USB_PORT_RELEASE_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_READ_FAILED_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_HEAD_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_BP_BE_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_SO_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_NAK_ENABLED 1
#define TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE_ENABLED 1
#define TRACE_USB_OHCI_PORT_ATTACH_ENABLED 1
#define TRACE_USB_OHCI_PORT_DETACH_ENABLED 1
#define TRACE_USB_OHCI_PORT_WAKEUP_ENABLED 1
#define TRACE_USB_OHCI_PORT_SUSPEND_ENABLED 1
#define TRACE_USB_OHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_OHCI_REMOTE_WAKEUP_ENABLED 1
#define TRACE_USB_OHCI_RESET_ENABLED 1
#define TRACE_USB_OHCI_START_ENABLED 1
#define TRACE_USB_OHCI_RESUME_ENABLED 1
#define TRACE_USB_OHCI_STOP_ENABLED 1
#define TRACE_USB_OHCI_EXIT_ENABLED 1
#define TRACE_USB_OHCI_SET_CTL_ENABLED 1
#define TRACE_USB_OHCI_TD_UNDERRUN_ENABLED 1
#define TRACE_USB_OHCI_TD_DEV_ERROR_ENABLED 1
#define TRACE_USB_OHCI_TD_NAK_ENABLED 1
#define TRACE_USB_OHCI_TD_STALL_ENABLED 1
#define TRACE_USB_OHCI_TD_BABBLE_ENABLED 1
#define TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE_ENABLED 1
#define TRACE_USB_OHCI_TD_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_TD_BAD_DIRECTION_ENABLED 1
#define TRACE_USB_OHCI_TD_SKIP_ASYNC_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_HDR_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_SHORT_ENABLED 1
#define TRACE_USB_OHCI_TD_PKT_FULL_ENABLED 1
#define TRACE_USB_OHCI_TD_TOO_MANY_PENDING_ENABLED 1
#define TRACE_USB_OHCI_TD_PACKET_STATUS_ENABLED 1
#define TRACE_USB_OHCI_ED_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_ED_PKT_ENABLED 1
#define TRACE_USB_OHCI_ED_PKT_FLAGS_ENABLED 1
#define TRACE_USB_OHCI_HCCA_READ_ERROR_ENABLED 1
#define TRACE_USB_OHCI_MEM_READ_UNALIGNED_ENABLED 1
#define TRACE_USB_OHCI_MEM_READ_BAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_MEM_WRITE_UNALIGNED_ENABLED 1
#define TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET_ENABLED 1
#define TRACE_USB_OHCI_PROCESS_LISTS_ENABLED 1
#define TRACE_USB_OHCI_SET_FRAME_INTERVAL_ENABLED 1
#define TRACE_USB_OHCI_HUB_POWER_UP_ENABLED 1
#define TRACE_USB_OHCI_HUB_POWER_DOWN_ENABLED 1
#define TRACE_USB_OHCI_INIT_TIME_ENABLED 1
#define TRACE_USB_OHCI_DIE_ENABLED 1
#define TRACE_USB_OHCI_ASYNC_COMPLETE_ENABLED 1
#define TRACE_USB_EHCI_RESET_ENABLED 1
#define TRACE_USB_EHCI_UNREALIZE_ENABLED 1
#define TRACE_USB_EHCI_OPREG_READ_ENABLED 1
#define TRACE_USB_EHCI_OPREG_WRITE_ENABLED 1
#define TRACE_USB_EHCI_OPREG_CHANGE_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_READ_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_WRITE_ENABLED 1
#define TRACE_USB_EHCI_PORTSC_CHANGE_ENABLED 1
#define TRACE_USB_EHCI_USBSTS_ENABLED 1
#define TRACE_USB_EHCI_STATE_ENABLED 1
#define TRACE_USB_EHCI_QH_PTRS_ENABLED 1
#define TRACE_USB_EHCI_QH_FIELDS_ENABLED 1
#define TRACE_USB_EHCI_QH_BITS_ENABLED 1
#define TRACE_USB_EHCI_QTD_PTRS_ENABLED 1
#define TRACE_USB_EHCI_QTD_FIELDS_ENABLED 1
#define TRACE_USB_EHCI_QTD_BITS_ENABLED 1
#define TRACE_USB_EHCI_ITD_ENABLED 1
#define TRACE_USB_EHCI_SITD_ENABLED 1
#define TRACE_USB_EHCI_PORT_ATTACH_ENABLED 1
#define TRACE_USB_EHCI_PORT_DETACH_ENABLED 1
#define TRACE_USB_EHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_EHCI_PORT_SUSPEND_ENABLED 1
#define TRACE_USB_EHCI_PORT_WAKEUP_ENABLED 1
#define TRACE_USB_EHCI_PORT_RESUME_ENABLED 1
#define TRACE_USB_EHCI_QUEUE_ACTION_ENABLED 1
#define TRACE_USB_EHCI_PACKET_ACTION_ENABLED 1
#define TRACE_USB_EHCI_IRQ_ENABLED 1
#define TRACE_USB_EHCI_GUEST_BUG_ENABLED 1
#define TRACE_USB_EHCI_DOORBELL_RING_ENABLED 1
#define TRACE_USB_EHCI_DOORBELL_ACK_ENABLED 1
#define TRACE_USB_EHCI_DMA_ERROR_ENABLED 1
#define TRACE_USB_UHCI_RESET_ENABLED 1
#define TRACE_USB_UHCI_EXIT_ENABLED 1
#define TRACE_USB_UHCI_SCHEDULE_START_ENABLED 1
#define TRACE_USB_UHCI_SCHEDULE_STOP_ENABLED 1
#define TRACE_USB_UHCI_FRAME_START_ENABLED 1
#define TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH_ENABLED 1
#define TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE_ENABLED 1
#define TRACE_USB_UHCI_FRAME_LOOP_CONTINUE_ENABLED 1
#define TRACE_USB_UHCI_MMIO_READW_ENABLED 1
#define TRACE_USB_UHCI_MMIO_WRITEW_ENABLED 1
#define TRACE_USB_UHCI_QUEUE_ADD_ENABLED 1
#define TRACE_USB_UHCI_QUEUE_DEL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_ADD_ENABLED 1
#define TRACE_USB_UHCI_PACKET_LINK_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_PACKET_UNLINK_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_PACKET_CANCEL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_STALL_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE_ENABLED 1
#define TRACE_USB_UHCI_PACKET_COMPLETE_ERROR_ENABLED 1
#define TRACE_USB_UHCI_PACKET_DEL_ENABLED 1
#define TRACE_USB_UHCI_QH_LOAD_ENABLED 1
#define TRACE_USB_UHCI_TD_LOAD_ENABLED 1
#define TRACE_USB_UHCI_TD_QUEUE_ENABLED 1
#define TRACE_USB_UHCI_TD_NEXTQH_ENABLED 1
#define TRACE_USB_UHCI_TD_ASYNC_ENABLED 1
#define TRACE_USB_UHCI_TD_COMPLETE_ENABLED 1
#define TRACE_USB_XHCI_RESET_ENABLED 1
#define TRACE_USB_XHCI_EXIT_ENABLED 1
#define TRACE_USB_XHCI_RUN_ENABLED 1
#define TRACE_USB_XHCI_STOP_ENABLED 1
#define TRACE_USB_XHCI_CAP_READ_ENABLED 1
#define TRACE_USB_XHCI_OPER_READ_ENABLED 1
#define TRACE_USB_XHCI_PORT_READ_ENABLED 1
#define TRACE_USB_XHCI_RUNTIME_READ_ENABLED 1
#define TRACE_USB_XHCI_DOORBELL_READ_ENABLED 1
#define TRACE_USB_XHCI_OPER_WRITE_ENABLED 1
#define TRACE_USB_XHCI_PORT_WRITE_ENABLED 1
#define TRACE_USB_XHCI_RUNTIME_WRITE_ENABLED 1
#define TRACE_USB_XHCI_DOORBELL_WRITE_ENABLED 1
#define TRACE_USB_XHCI_IRQ_INTX_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSI_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_USE_ENABLED 1
#define TRACE_USB_XHCI_IRQ_MSIX_UNUSE_ENABLED 1
#define TRACE_USB_XHCI_QUEUE_EVENT_ENABLED 1
#define TRACE_USB_XHCI_FETCH_TRB_ENABLED 1
#define TRACE_USB_XHCI_PORT_RESET_ENABLED 1
#define TRACE_USB_XHCI_PORT_LINK_ENABLED 1
#define TRACE_USB_XHCI_PORT_NOTIFY_ENABLED 1
#define TRACE_USB_XHCI_SLOT_ENABLE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_DISABLE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_ADDRESS_ENABLED 1
#define TRACE_USB_XHCI_SLOT_CONFIGURE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_EVALUATE_ENABLED 1
#define TRACE_USB_XHCI_SLOT_RESET_ENABLED 1
#define TRACE_USB_XHCI_EP_ENABLE_ENABLED 1
#define TRACE_USB_XHCI_EP_DISABLE_ENABLED 1
#define TRACE_USB_XHCI_EP_SET_DEQUEUE_ENABLED 1
#define TRACE_USB_XHCI_EP_KICK_ENABLED 1
#define TRACE_USB_XHCI_EP_STOP_ENABLED 1
#define TRACE_USB_XHCI_EP_RESET_ENABLED 1
#define TRACE_USB_XHCI_EP_STATE_ENABLED 1
#define TRACE_USB_XHCI_XFER_START_ENABLED 1
#define TRACE_USB_XHCI_XFER_ASYNC_ENABLED 1
#define TRACE_USB_XHCI_XFER_NAK_ENABLED 1
#define TRACE_USB_XHCI_XFER_RETRY_ENABLED 1
#define TRACE_USB_XHCI_XFER_SUCCESS_ENABLED 1
#define TRACE_USB_XHCI_XFER_ERROR_ENABLED 1
#define TRACE_USB_XHCI_UNIMPLEMENTED_ENABLED 1
#define TRACE_USB_XHCI_ENFORCED_LIMIT_ENABLED 1
#define TRACE_USB_DESC_DEVICE_ENABLED 1
#define TRACE_USB_DESC_DEVICE_QUALIFIER_ENABLED 1
#define TRACE_USB_DESC_CONFIG_ENABLED 1
#define TRACE_USB_DESC_OTHER_SPEED_CONFIG_ENABLED 1
#define TRACE_USB_DESC_STRING_ENABLED 1
#define TRACE_USB_DESC_BOS_ENABLED 1
#define TRACE_USB_DESC_MSOS_ENABLED 1
#define TRACE_USB_SET_ADDR_ENABLED 1
#define TRACE_USB_SET_CONFIG_ENABLED 1
#define TRACE_USB_SET_INTERFACE_ENABLED 1
#define TRACE_USB_CLEAR_DEVICE_FEATURE_ENABLED 1
#define TRACE_USB_SET_DEVICE_FEATURE_ENABLED 1
#define TRACE_USB_HUB_RESET_ENABLED 1
#define TRACE_USB_HUB_CONTROL_ENABLED 1
#define TRACE_USB_HUB_GET_PORT_STATUS_ENABLED 1
#define TRACE_USB_HUB_SET_PORT_FEATURE_ENABLED 1
#define TRACE_USB_HUB_CLEAR_PORT_FEATURE_ENABLED 1
#define TRACE_USB_HUB_ATTACH_ENABLED 1
#define TRACE_USB_HUB_DETACH_ENABLED 1
#define TRACE_USB_HUB_STATUS_REPORT_ENABLED 1
#define TRACE_USB_UAS_RESET_ENABLED 1
#define TRACE_USB_UAS_COMMAND_ENABLED 1
#define TRACE_USB_UAS_RESPONSE_ENABLED 1
#define TRACE_USB_UAS_SENSE_ENABLED 1
#define TRACE_USB_UAS_READ_READY_ENABLED 1
#define TRACE_USB_UAS_WRITE_READY_ENABLED 1
#define TRACE_USB_UAS_XFER_DATA_ENABLED 1
#define TRACE_USB_UAS_SCSI_DATA_ENABLED 1
#define TRACE_USB_UAS_SCSI_COMPLETE_ENABLED 1
#define TRACE_USB_UAS_TMF_ABORT_TASK_ENABLED 1
#define TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET_ENABLED 1
#define TRACE_USB_UAS_TMF_UNSUPPORTED_ENABLED 1
#define TRACE_USB_MTP_RESET_ENABLED 1
#define TRACE_USB_MTP_COMMAND_ENABLED 1
#define TRACE_USB_MTP_SUCCESS_ENABLED 1
#define TRACE_USB_MTP_ERROR_ENABLED 1
#define TRACE_USB_MTP_DATA_IN_ENABLED 1
#define TRACE_USB_MTP_XFER_ENABLED 1
#define TRACE_USB_MTP_NAK_ENABLED 1
#define TRACE_USB_MTP_STALL_ENABLED 1
#define TRACE_USB_MTP_OP_GET_DEVICE_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_OPEN_SESSION_ENABLED 1
#define TRACE_USB_MTP_OP_CLOSE_SESSION_ENABLED 1
#define TRACE_USB_MTP_OP_GET_STORAGE_IDS_ENABLED 1
#define TRACE_USB_MTP_OP_GET_STORAGE_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_GET_NUM_OBJECTS_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_HANDLES_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_INFO_ENABLED 1
#define TRACE_USB_MTP_OP_GET_OBJECT_ENABLED 1
#define TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT_ENABLED 1
#define TRACE_USB_MTP_OP_UNKNOWN_ENABLED 1
#define TRACE_USB_MTP_OBJECT_ALLOC_ENABLED 1
#define TRACE_USB_MTP_OBJECT_FREE_ENABLED 1
#define TRACE_USB_MTP_ADD_CHILD_ENABLED 1
#define TRACE_USB_MTP_INOTIFY_EVENT_ENABLED 1
#define TRACE_USB_HOST_OPEN_STARTED_ENABLED 1
#define TRACE_USB_HOST_OPEN_SUCCESS_ENABLED 1
#define TRACE_USB_HOST_OPEN_FAILURE_ENABLED 1
#define TRACE_USB_HOST_CLOSE_ENABLED 1
#define TRACE_USB_HOST_ATTACH_KERNEL_ENABLED 1
#define TRACE_USB_HOST_DETACH_KERNEL_ENABLED 1
#define TRACE_USB_HOST_SET_ADDRESS_ENABLED 1
#define TRACE_USB_HOST_SET_CONFIG_ENABLED 1
#define TRACE_USB_HOST_SET_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_CLAIM_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_RELEASE_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_REQ_CONTROL_ENABLED 1
#define TRACE_USB_HOST_REQ_DATA_ENABLED 1
#define TRACE_USB_HOST_REQ_COMPLETE_ENABLED 1
#define TRACE_USB_HOST_REQ_EMULATED_ENABLED 1
#define TRACE_USB_HOST_REQ_CANCELED_ENABLED 1
#define TRACE_USB_HOST_ISO_START_ENABLED 1
#define TRACE_USB_HOST_ISO_STOP_ENABLED 1
#define TRACE_USB_HOST_ISO_OUT_OF_BUFS_ENABLED 1
#define TRACE_USB_HOST_RESET_ENABLED 1
#define TRACE_USB_HOST_AUTO_SCAN_ENABLED_ENABLED 1
#define TRACE_USB_HOST_AUTO_SCAN_DISABLED_ENABLED 1
#define TRACE_USB_HOST_PARSE_CONFIG_ENABLED 1
#define TRACE_USB_HOST_PARSE_INTERFACE_ENABLED 1
#define TRACE_USB_HOST_PARSE_ENDPOINT_ENABLED 1
#define TRACE_USB_HOST_PARSE_ERROR_ENABLED 1
#include "qemu/log.h"


static inline void trace_usb_packet_state_change(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PACKET_STATE_CHANGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_packet_state_change " "bus %d, port %s, ep %d, packet %p, state %s -> %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port, ep, p, o, n);
        }
    }
}

static inline void trace_usb_packet_state_fault(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PACKET_STATE_FAULT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_packet_state_fault " "bus %d, port %s, ep %d, packet %p, state %s, expected %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port, ep, p, o, n);
        }
    }
}

static inline void trace_usb_port_claim(int bus, const char * port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PORT_CLAIM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_port_claim " "bus %d, port %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port);
        }
    }
}

static inline void trace_usb_port_attach(int bus, const char * port, const char * devspeed, const char * portspeed)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PORT_ATTACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_port_attach " "bus %d, port %s, devspeed %s, portspeed %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port, devspeed, portspeed);
        }
    }
}

static inline void trace_usb_port_detach(int bus, const char * port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PORT_DETACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_port_detach " "bus %d, port %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port);
        }
    }
}

static inline void trace_usb_port_release(int bus, const char * port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_PORT_RELEASE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_port_release " "bus %d, port %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, port);
        }
    }
}

static inline void trace_usb_ohci_iso_td_read_failed(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_READ_FAILED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_read_failed " "ISO_TD read error at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_iso_td_head(uint32_t head, uint32_t tail, uint32_t flags, uint32_t bp, uint32_t next, uint32_t be, uint32_t framenum, uint32_t startframe, uint32_t framecount, int rel_frame_num)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_HEAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_head " "ISO_TD ED head 0x%.8x tailp 0x%.8x\n0x%.8x 0x%.8x 0x%.8x 0x%.8x\nframe_number 0x%.8x starting_frame 0x%.8x\nframe_count  0x%.8x relative %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , head, tail, flags, bp, next, be, framenum, startframe, framecount, rel_frame_num);
        }
    }
}

static inline void trace_usb_ohci_iso_td_head_offset(uint32_t o0, uint32_t o1, uint32_t o2, uint32_t o3, uint32_t o4, uint32_t o5, uint32_t o6, uint32_t o7)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_HEAD_OFFSET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_head_offset " "0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x 0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , o0, o1, o2, o3, o4, o5, o6, o7);
        }
    }
}

static inline void trace_usb_ohci_iso_td_relative_frame_number_neg(int rel)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_NEG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_relative_frame_number_neg " "ISO_TD R=%d < 0" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rel);
        }
    }
}

static inline void trace_usb_ohci_iso_td_relative_frame_number_big(int rel, int count)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_RELATIVE_FRAME_NUMBER_BIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_relative_frame_number_big " "ISO_TD R=%d > FC=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rel, count);
        }
    }
}

static inline void trace_usb_ohci_iso_td_bad_direction(int dir)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_DIRECTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_bad_direction " "Bad direction %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dir);
        }
    }
}

static inline void trace_usb_ohci_iso_td_bad_bp_be(uint32_t bp, uint32_t be)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_BP_BE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_bad_bp_be " "ISO_TD bp 0x%.8x be 0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bp, be);
        }
    }
}

static inline void trace_usb_ohci_iso_td_bad_cc_not_accessed(uint32_t start, uint32_t next)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_CC_NOT_ACCESSED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_bad_cc_not_accessed " "ISO_TD cc != not accessed 0x%.8x 0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, next);
        }
    }
}

static inline void trace_usb_ohci_iso_td_bad_cc_overrun(uint32_t start, uint32_t next)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_CC_OVERRUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_bad_cc_overrun " "ISO_TD start_offset=0x%.8x > next_offset=0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, next);
        }
    }
}

static inline void trace_usb_ohci_iso_td_so(uint32_t so, uint32_t eo, uint32_t s, uint32_t e, const char * str, ssize_t len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_SO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_so " "0x%.8x eo 0x%.8x\nsa 0x%.8x ea 0x%.8x\ndir %s len %zu ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , so, eo, s, e, str, len, ret);
        }
    }
}

static inline void trace_usb_ohci_iso_td_data_overrun(int ret, ssize_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_DATA_OVERRUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_data_overrun " "DataOverrun %d > %zu" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ret, len);
        }
    }
}

static inline void trace_usb_ohci_iso_td_data_underrun(int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_DATA_UNDERRUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_data_underrun " "DataUnderrun %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ret);
        }
    }
}

static inline void trace_usb_ohci_iso_td_nak(int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_NAK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_nak " "got NAK/STALL %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ret);
        }
    }
}

static inline void trace_usb_ohci_iso_td_bad_response(int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ISO_TD_BAD_RESPONSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_iso_td_bad_response " "Bad device response %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ret);
        }
    }
}

static inline void trace_usb_ohci_port_attach(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PORT_ATTACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_port_attach " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_usb_ohci_port_detach(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PORT_DETACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_port_detach " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_usb_ohci_port_wakeup(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PORT_WAKEUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_port_wakeup " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_usb_ohci_port_suspend(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PORT_SUSPEND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_port_suspend " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_usb_ohci_port_reset(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PORT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_port_reset " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_usb_ohci_remote_wakeup(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_REMOTE_WAKEUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_remote_wakeup " "%s: SUSPEND->RESUME" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_reset(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_reset " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_start(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_start " "%s: USB Operational" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_resume(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_RESUME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_resume " "%s: USB Resume" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_stop(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_stop " "%s: USB Suspended" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_exit(const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_exit " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s);
        }
    }
}

static inline void trace_usb_ohci_set_ctl(const char * s, uint32_t new_state)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_SET_CTL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_set_ctl " "%s: new state 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , s, new_state);
        }
    }
}

static inline void trace_usb_ohci_td_underrun(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_UNDERRUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_underrun " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_dev_error(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_DEV_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_dev_error " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_nak(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_NAK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_nak " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_stall(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_STALL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_stall " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_babble(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_BABBLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_babble " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_bad_device_response(int rc)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_BAD_DEVICE_RESPONSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_bad_device_response " "%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , rc);
        }
    }
}

static inline void trace_usb_ohci_td_read_error(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_READ_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_read_error " "TD read error at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_td_bad_direction(int dir)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_BAD_DIRECTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_bad_direction " "Bad direction %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dir);
        }
    }
}

static inline void trace_usb_ohci_td_skip_async(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_SKIP_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_skip_async " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_pkt_hdr(uint32_t addr, int64_t pktlen, int64_t len, const char * s, int flag_r, uint32_t cbp, uint32_t be)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_HDR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_pkt_hdr " " TD @ 0x%.8x %" PRId64 " of %" PRId64 " bytes %s r=%d cbp=0x%.8x be=0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, pktlen, len, s, flag_r, cbp, be);
        }
    }
}

static inline void trace_usb_ohci_td_pkt_short(const char * dir, const char * buf)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_pkt_short " "%s data: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dir, buf);
        }
    }
}

static inline void trace_usb_ohci_td_pkt_full(const char * dir, const char * buf)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_pkt_full " "%s data: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dir, buf);
        }
    }
}

static inline void trace_usb_ohci_td_too_many_pending(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_TOO_MANY_PENDING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_too_many_pending " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_td_packet_status(int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_TD_PACKET_STATUS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_td_packet_status " "status=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , status);
        }
    }
}

static inline void trace_usb_ohci_ed_read_error(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ED_READ_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_ed_read_error " "ED read error at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_ed_pkt(uint32_t cur, int h, int c, uint32_t head, uint32_t tail, uint32_t next)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ED_PKT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_ed_pkt " "ED @ 0x%.8x h=%u c=%u\n  head=0x%.8x tailp=0x%.8x next=0x%.8x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , cur, h, c, head, tail, next);
        }
    }
}

static inline void trace_usb_ohci_ed_pkt_flags(uint32_t fa, uint32_t en, uint32_t d, int s, int k, int f, uint32_t mps)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ED_PKT_FLAGS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_ed_pkt_flags " "fa=%u en=%u d=%u s=%u k=%u f=%u mps=%u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , fa, en, d, s, k, f, mps);
        }
    }
}

static inline void trace_usb_ohci_hcca_read_error(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_HCCA_READ_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_hcca_read_error " "HCCA read error at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_mem_read_unaligned(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_MEM_READ_UNALIGNED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_mem_read_unaligned " "at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_mem_read_bad_offset(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_MEM_READ_BAD_OFFSET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_mem_read_bad_offset " "%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_mem_write_unaligned(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_MEM_WRITE_UNALIGNED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_mem_write_unaligned " "at %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_mem_write_bad_offset(uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_MEM_WRITE_BAD_OFFSET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_mem_write_bad_offset " "%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_ohci_process_lists(uint32_t head, uint32_t cur)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_PROCESS_LISTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_process_lists " "head %x, cur %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , head, cur);
        }
    }
}

static inline void trace_usb_ohci_set_frame_interval(const char * name, uint16_t fi_x, uint16_t fi_u)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_SET_FRAME_INTERVAL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_set_frame_interval " "%s: FrameInterval = 0x%x (%u)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, fi_x, fi_u);
        }
    }
}

static inline void trace_usb_ohci_hub_power_up(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_HUB_POWER_UP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_hub_power_up " "powered up all ports" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_hub_power_down(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_HUB_POWER_DOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_hub_power_down " "powered down all ports" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_init_time(int64_t frametime, int64_t bittime)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_INIT_TIME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_init_time " "usb_bit_time=%" PRId64 " usb_frame_time=%" PRId64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , frametime, bittime);
        }
    }
}

static inline void trace_usb_ohci_die(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_DIE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_die " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ohci_async_complete(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_OHCI_ASYNC_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ohci_async_complete " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ehci_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_reset " "=== RESET ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ehci_unrealize(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_UNREALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_unrealize " "=== UNREALIZE ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ehci_opreg_read(uint32_t addr, const char * str, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_OPREG_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_opreg_read " "rd mmio %04x [%s] = %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, str, val);
        }
    }
}

static inline void trace_usb_ehci_opreg_write(uint32_t addr, const char * str, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_OPREG_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_opreg_write " "wr mmio %04x [%s] = %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, str, val);
        }
    }
}

static inline void trace_usb_ehci_opreg_change(uint32_t addr, const char * str, uint32_t new, uint32_t old)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_OPREG_CHANGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_opreg_change " "ch mmio %04x [%s] = %x (old: %x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, str, new, old);
        }
    }
}

static inline void trace_usb_ehci_portsc_read(uint32_t addr, uint32_t port, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_portsc_read " "rd mmio %04x [port %d] = %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, port, val);
        }
    }
}

static inline void trace_usb_ehci_portsc_write(uint32_t addr, uint32_t port, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_portsc_write " "wr mmio %04x [port %d] = %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, port, val);
        }
    }
}

static inline void trace_usb_ehci_portsc_change(uint32_t addr, uint32_t port, uint32_t new, uint32_t old)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORTSC_CHANGE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_portsc_change " "ch mmio %04x [port %d] = %x (old: %x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, port, new, old);
        }
    }
}

static inline void trace_usb_ehci_usbsts(const char * sts, int state)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_USBSTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_usbsts " "usbsts %s %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , sts, state);
        }
    }
}

static inline void trace_usb_ehci_state(const char * schedule, const char * state)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_state " "%s schedule %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , schedule, state);
        }
    }
}

static inline void trace_usb_ehci_qh_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t c_qtd, uint32_t n_qtd, uint32_t a_qtd)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QH_PTRS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qh_ptrs " "q %p - QH @ %08x: next %08x qtds %08x,%08x,%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , q, addr, nxt, c_qtd, n_qtd, a_qtd);
        }
    }
}

static inline void trace_usb_ehci_qh_fields(uint32_t addr, int rl, int mplen, int eps, int ep, int devaddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QH_FIELDS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qh_fields " "QH @ %08x - rl %d, mplen %d, eps %d, ep %d, dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, rl, mplen, eps, ep, devaddr);
        }
    }
}

static inline void trace_usb_ehci_qh_bits(uint32_t addr, int c, int h, int dtc, int i)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QH_BITS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qh_bits " "QH @ %08x - c %d, h %d, dtc %d, i %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, c, h, dtc, i);
        }
    }
}

static inline void trace_usb_ehci_qtd_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t altnext)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QTD_PTRS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qtd_ptrs " "q %p - QTD @ %08x: next %08x altnext %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , q, addr, nxt, altnext);
        }
    }
}

static inline void trace_usb_ehci_qtd_fields(uint32_t addr, int tbytes, int cpage, int cerr, int pid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QTD_FIELDS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qtd_fields " "QTD @ %08x - tbytes %d, cpage %d, cerr %d, pid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tbytes, cpage, cerr, pid);
        }
    }
}

static inline void trace_usb_ehci_qtd_bits(uint32_t addr, int ioc, int active, int halt, int babble, int xacterr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QTD_BITS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_qtd_bits " "QTD @ %08x - ioc %d, active %d, halt %d, babble %d, xacterr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, ioc, active, halt, babble, xacterr);
        }
    }
}

static inline void trace_usb_ehci_itd(uint32_t addr, uint32_t nxt, uint32_t mplen, uint32_t mult, uint32_t ep, uint32_t devaddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_ITD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_itd " "ITD @ %08x: next %08x - mplen %d, mult %d, ep %d, dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nxt, mplen, mult, ep, devaddr);
        }
    }
}

static inline void trace_usb_ehci_sitd(uint32_t addr, uint32_t nxt, uint32_t active)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_SITD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_sitd " "ITD @ %08x: next %08x - active %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nxt, active);
        }
    }
}

static inline void trace_usb_ehci_port_attach(uint32_t port, const char * owner, const char * device)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_ATTACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_attach " "attach port #%d, owner %s, device %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, owner, device);
        }
    }
}

static inline void trace_usb_ehci_port_detach(uint32_t port, const char * owner)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_DETACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_detach " "detach port #%d, owner %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, owner);
        }
    }
}

static inline void trace_usb_ehci_port_reset(uint32_t port, int enable)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_reset " "reset port #%d - %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, enable);
        }
    }
}

static inline void trace_usb_ehci_port_suspend(uint32_t port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_SUSPEND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_suspend " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port);
        }
    }
}

static inline void trace_usb_ehci_port_wakeup(uint32_t port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_WAKEUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_wakeup " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port);
        }
    }
}

static inline void trace_usb_ehci_port_resume(uint32_t port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PORT_RESUME)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_port_resume " "port #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port);
        }
    }
}

static inline void trace_usb_ehci_queue_action(void * q, const char * action)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_QUEUE_ACTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_queue_action " "q %p: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , q, action);
        }
    }
}

static inline void trace_usb_ehci_packet_action(void * q, void * p, const char * action)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_PACKET_ACTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_packet_action " "q %p p %p: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , q, p, action);
        }
    }
}

static inline void trace_usb_ehci_irq(uint32_t level, uint32_t frindex, uint32_t sts, uint32_t mask)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_IRQ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_irq " "level %d, frindex 0x%04x, sts 0x%x, mask 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , level, frindex, sts, mask);
        }
    }
}

static inline void trace_usb_ehci_guest_bug(const char * reason)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_GUEST_BUG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_guest_bug " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , reason);
        }
    }
}

static inline void trace_usb_ehci_doorbell_ring(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_DOORBELL_RING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_doorbell_ring " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ehci_doorbell_ack(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_DOORBELL_ACK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_doorbell_ack " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_ehci_dma_error(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_EHCI_DMA_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_ehci_dma_error " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_reset " "=== RESET ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_exit(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_exit " "=== EXIT ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_schedule_start(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_schedule_start " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_schedule_stop(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_schedule_stop " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_frame_start(uint32_t num)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_FRAME_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_frame_start " "nr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , num);
        }
    }
}

static inline void trace_usb_uhci_frame_stop_bandwidth(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_frame_stop_bandwidth " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_frame_loop_stop_idle(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_frame_loop_stop_idle " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_frame_loop_continue(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_CONTINUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_frame_loop_continue " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_uhci_mmio_readw(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_MMIO_READW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_mmio_readw " "addr 0x%04x, ret 0x%04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_usb_uhci_mmio_writew(uint32_t addr, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_MMIO_WRITEW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_mmio_writew " "addr 0x%04x, val 0x%04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, val);
        }
    }
}

static inline void trace_usb_uhci_queue_add(uint32_t token)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_QUEUE_ADD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_queue_add " "token 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token);
        }
    }
}

static inline void trace_usb_uhci_queue_del(uint32_t token, const char * reason)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_QUEUE_DEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_queue_del " "token 0x%x: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, reason);
        }
    }
}

static inline void trace_usb_uhci_packet_add(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_ADD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_add " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_link_async(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_LINK_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_link_async " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_unlink_async(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_UNLINK_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_unlink_async " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_cancel(uint32_t token, uint32_t addr, int done)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_CANCEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_cancel " "token 0x%x, td 0x%x, done %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr, done);
        }
    }
}

static inline void trace_usb_uhci_packet_complete_success(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_complete_success " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_complete_shortxfer(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_complete_shortxfer " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_complete_stall(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_STALL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_complete_stall " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_complete_babble(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_complete_babble " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_complete_error(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_complete_error " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_packet_del(uint32_t token, uint32_t addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_PACKET_DEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_packet_del " "token 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , token, addr);
        }
    }
}

static inline void trace_usb_uhci_qh_load(uint32_t qh)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_QH_LOAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_qh_load " "qh 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qh);
        }
    }
}

static inline void trace_usb_uhci_td_load(uint32_t qh, uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_TD_LOAD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_td_load " "qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qh, td, ctrl, token);
        }
    }
}

static inline void trace_usb_uhci_td_queue(uint32_t td, uint32_t ctrl, uint32_t token)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_TD_QUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_td_queue " "td 0x%x, ctrl 0x%x, token 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , td, ctrl, token);
        }
    }
}

static inline void trace_usb_uhci_td_nextqh(uint32_t qh, uint32_t td)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_TD_NEXTQH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_td_nextqh " "qh 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qh, td);
        }
    }
}

static inline void trace_usb_uhci_td_async(uint32_t qh, uint32_t td)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_TD_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_td_async " "qh 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qh, td);
        }
    }
}

static inline void trace_usb_uhci_td_complete(uint32_t qh, uint32_t td)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UHCI_TD_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uhci_td_complete " "qh 0x%x, td 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , qh, td);
        }
    }
}

static inline void trace_usb_xhci_reset(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_reset " "=== RESET ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_xhci_exit(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_exit " "=== EXIT ===" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_xhci_run(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_RUN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_run " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_xhci_stop(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_stop " "" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_xhci_cap_read(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_CAP_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_cap_read " "off 0x%04x, ret 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_oper_read(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_OPER_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_oper_read " "off 0x%04x, ret 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_port_read(uint32_t port, uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_PORT_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_port_read " "port %d, off 0x%04x, ret 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, off, val);
        }
    }
}

static inline void trace_usb_xhci_runtime_read(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_RUNTIME_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_runtime_read " "off 0x%04x, ret 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_doorbell_read(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_DOORBELL_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_doorbell_read " "off 0x%04x, ret 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_oper_write(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_OPER_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_oper_write " "off 0x%04x, val 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_port_write(uint32_t port, uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_PORT_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_port_write " "port %d, off 0x%04x, val 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, off, val);
        }
    }
}

static inline void trace_usb_xhci_runtime_write(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_RUNTIME_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_runtime_write " "off 0x%04x, val 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_doorbell_write(uint32_t off, uint32_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_DOORBELL_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_doorbell_write " "off 0x%04x, val 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off, val);
        }
    }
}

static inline void trace_usb_xhci_irq_intx(uint32_t level)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_IRQ_INTX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_irq_intx " "level %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , level);
        }
    }
}

static inline void trace_usb_xhci_irq_msi(uint32_t nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_irq_msi " "nr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nr);
        }
    }
}

static inline void trace_usb_xhci_irq_msix(uint32_t nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_irq_msix " "nr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nr);
        }
    }
}

static inline void trace_usb_xhci_irq_msix_use(uint32_t nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_USE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_irq_msix_use " "nr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nr);
        }
    }
}

static inline void trace_usb_xhci_irq_msix_unuse(uint32_t nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_UNUSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_irq_msix_unuse " "nr %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , nr);
        }
    }
}

static inline void trace_usb_xhci_queue_event(uint32_t vector, uint32_t idx, const char * trb, const char * evt, uint64_t param, uint32_t status, uint32_t control)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_QUEUE_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_queue_event " "v %d, idx %d, %s, %s, p %016" PRIx64 ", s %08x, c 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , vector, idx, trb, evt, param, status, control);
        }
    }
}

static inline void trace_usb_xhci_fetch_trb(uint64_t addr, const char * name, uint64_t param, uint32_t status, uint32_t control)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_FETCH_TRB)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_fetch_trb " "addr %016" PRIx64 ", %s, p %016" PRIx64 ", s %08x, c 0x%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, name, param, status, control);
        }
    }
}

static inline void trace_usb_xhci_port_reset(uint32_t port, bool warm)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_PORT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_port_reset " "port %d, warm %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, warm);
        }
    }
}

static inline void trace_usb_xhci_port_link(uint32_t port, uint32_t pls)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_PORT_LINK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_port_link " "port %d, pls %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, pls);
        }
    }
}

static inline void trace_usb_xhci_port_notify(uint32_t port, uint32_t pls)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_PORT_NOTIFY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_port_notify " "port %d, bits %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , port, pls);
        }
    }
}

static inline void trace_usb_xhci_slot_enable(uint32_t slotid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_enable " "slotid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid);
        }
    }
}

static inline void trace_usb_xhci_slot_disable(uint32_t slotid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_disable " "slotid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid);
        }
    }
}

static inline void trace_usb_xhci_slot_address(uint32_t slotid, const char * port)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_ADDRESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_address " "slotid %d, port %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, port);
        }
    }
}

static inline void trace_usb_xhci_slot_configure(uint32_t slotid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_CONFIGURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_configure " "slotid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid);
        }
    }
}

static inline void trace_usb_xhci_slot_evaluate(uint32_t slotid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_EVALUATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_evaluate " "slotid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid);
        }
    }
}

static inline void trace_usb_xhci_slot_reset(uint32_t slotid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_SLOT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_slot_reset " "slotid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid);
        }
    }
}

static inline void trace_usb_xhci_ep_enable(uint32_t slotid, uint32_t epid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_enable " "slotid %d, epid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid);
        }
    }
}

static inline void trace_usb_xhci_ep_disable(uint32_t slotid, uint32_t epid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_disable " "slotid %d, epid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid);
        }
    }
}

static inline void trace_usb_xhci_ep_set_dequeue(uint32_t slotid, uint32_t epid, uint32_t streamid, uint64_t param)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_SET_DEQUEUE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_set_dequeue " "slotid %d, epid %d, streamid %d, ptr %016" PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid, streamid, param);
        }
    }
}

static inline void trace_usb_xhci_ep_kick(uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_KICK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_kick " "slotid %d, epid %d, streamid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid, streamid);
        }
    }
}

static inline void trace_usb_xhci_ep_stop(uint32_t slotid, uint32_t epid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_stop " "slotid %d, epid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid);
        }
    }
}

static inline void trace_usb_xhci_ep_reset(uint32_t slotid, uint32_t epid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_reset " "slotid %d, epid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid);
        }
    }
}

static inline void trace_usb_xhci_ep_state(uint32_t slotid, uint32_t epid, const char * os, const char * ns)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_EP_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_ep_state " "slotid %d, epid %d, %s -> %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , slotid, epid, os, ns);
        }
    }
}

static inline void trace_usb_xhci_xfer_start(void * xfer, uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_start " "%p: slotid %d, epid %d, streamid %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer, slotid, epid, streamid);
        }
    }
}

static inline void trace_usb_xhci_xfer_async(void * xfer)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_ASYNC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_async " "%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer);
        }
    }
}

static inline void trace_usb_xhci_xfer_nak(void * xfer)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_NAK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_nak " "%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer);
        }
    }
}

static inline void trace_usb_xhci_xfer_retry(void * xfer)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_RETRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_retry " "%p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer);
        }
    }
}

static inline void trace_usb_xhci_xfer_success(void * xfer, uint32_t bytes)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_SUCCESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_success " "%p: len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer, bytes);
        }
    }
}

static inline void trace_usb_xhci_xfer_error(void * xfer, uint32_t ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_XFER_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_xfer_error " "%p: ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , xfer, ret);
        }
    }
}

static inline void trace_usb_xhci_unimplemented(const char * item, int nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_UNIMPLEMENTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_unimplemented " "%s (0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , item, nr);
        }
    }
}

static inline void trace_usb_xhci_enforced_limit(const char * item)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_XHCI_ENFORCED_LIMIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_xhci_enforced_limit " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , item);
        }
    }
}

static inline void trace_usb_desc_device(int addr, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_DEVICE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_device " "dev %d query device, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, len, ret);
        }
    }
}

static inline void trace_usb_desc_device_qualifier(int addr, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_DEVICE_QUALIFIER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_device_qualifier " "dev %d query device qualifier, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, len, ret);
        }
    }
}

static inline void trace_usb_desc_config(int addr, int index, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_config " "dev %d query config %d, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, index, len, ret);
        }
    }
}

static inline void trace_usb_desc_other_speed_config(int addr, int index, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_OTHER_SPEED_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_other_speed_config " "dev %d query config %d, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, index, len, ret);
        }
    }
}

static inline void trace_usb_desc_string(int addr, int index, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_STRING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_string " "dev %d query string %d, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, index, len, ret);
        }
    }
}

static inline void trace_usb_desc_bos(int addr, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_BOS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_bos " "dev %d bos, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, len, ret);
        }
    }
}

static inline void trace_usb_desc_msos(int addr, int index, int len, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_DESC_MSOS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_desc_msos " "dev %d msos, index 0x%x, len %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, index, len, ret);
        }
    }
}

static inline void trace_usb_set_addr(int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_SET_ADDR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_set_addr " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_set_config(int addr, int config, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_SET_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_set_config " "dev %d, config %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, config, ret);
        }
    }
}

static inline void trace_usb_set_interface(int addr, int iface, int alt, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_SET_INTERFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_set_interface " "dev %d, interface %d, altsetting %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, iface, alt, ret);
        }
    }
}

static inline void trace_usb_clear_device_feature(int addr, int feature, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_CLEAR_DEVICE_FEATURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_clear_device_feature " "dev %d, feature %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, feature, ret);
        }
    }
}

static inline void trace_usb_set_device_feature(int addr, int feature, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_SET_DEVICE_FEATURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_set_device_feature " "dev %d, feature %d, ret %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, feature, ret);
        }
    }
}

static inline void trace_usb_hub_reset(int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_reset " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_hub_control(int addr, int request, int value, int index, int length)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_CONTROL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_control " "dev %d, req 0x%x, value %d, index %d, langth %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, request, value, index, length);
        }
    }
}

static inline void trace_usb_hub_get_port_status(int addr, int nr, int status, int changed)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_GET_PORT_STATUS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_get_port_status " "dev %d, port %d, status 0x%x, changed 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nr, status, changed);
        }
    }
}

static inline void trace_usb_hub_set_port_feature(int addr, int nr, const char * f)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_SET_PORT_FEATURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_set_port_feature " "dev %d, port %d, feature %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nr, f);
        }
    }
}

static inline void trace_usb_hub_clear_port_feature(int addr, int nr, const char * f)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_CLEAR_PORT_FEATURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_clear_port_feature " "dev %d, port %d, feature %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nr, f);
        }
    }
}

static inline void trace_usb_hub_attach(int addr, int nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_ATTACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_attach " "dev %d, port %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nr);
        }
    }
}

static inline void trace_usb_hub_detach(int addr, int nr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_DETACH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_detach " "dev %d, port %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, nr);
        }
    }
}

static inline void trace_usb_hub_status_report(int addr, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HUB_STATUS_REPORT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_hub_status_report " "dev %d, status 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, status);
        }
    }
}

static inline void trace_usb_uas_reset(int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_reset " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_uas_command(int addr, uint16_t tag, int lun, uint32_t lun64_1, uint32_t lun64_2)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_COMMAND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_command " "dev %d, tag 0x%x, lun %d, lun64 %08x-%08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, lun, lun64_1, lun64_2);
        }
    }
}

static inline void trace_usb_uas_response(int addr, uint16_t tag, uint8_t code)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_RESPONSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_response " "dev %d, tag 0x%x, code 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, code);
        }
    }
}

static inline void trace_usb_uas_sense(int addr, uint16_t tag, uint8_t status)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_SENSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_sense " "dev %d, tag 0x%x, status 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, status);
        }
    }
}

static inline void trace_usb_uas_read_ready(int addr, uint16_t tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_READ_READY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_read_ready " "dev %d, tag 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag);
        }
    }
}

static inline void trace_usb_uas_write_ready(int addr, uint16_t tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_WRITE_READY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_write_ready " "dev %d, tag 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag);
        }
    }
}

static inline void trace_usb_uas_xfer_data(int addr, uint16_t tag, uint32_t copy, uint32_t uoff, uint32_t usize, uint32_t soff, uint32_t ssize)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_XFER_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_xfer_data " "dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, copy, uoff, usize, soff, ssize);
        }
    }
}

static inline void trace_usb_uas_scsi_data(int addr, uint16_t tag, uint32_t bytes)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_SCSI_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_scsi_data " "dev %d, tag 0x%x, bytes %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, bytes);
        }
    }
}

static inline void trace_usb_uas_scsi_complete(int addr, uint16_t tag, uint32_t status, uint32_t resid)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_SCSI_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_scsi_complete " "dev %d, tag 0x%x, status 0x%x, residue %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, status, resid);
        }
    }
}

static inline void trace_usb_uas_tmf_abort_task(int addr, uint16_t tag, uint16_t task_tag)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_TMF_ABORT_TASK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_tmf_abort_task " "dev %d, tag 0x%x, task-tag 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, task_tag);
        }
    }
}

static inline void trace_usb_uas_tmf_logical_unit_reset(int addr, uint16_t tag, int lun)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_tmf_logical_unit_reset " "dev %d, tag 0x%x, lun %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, lun);
        }
    }
}

static inline void trace_usb_uas_tmf_unsupported(int addr, uint16_t tag, uint32_t function)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_UAS_TMF_UNSUPPORTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_uas_tmf_unsupported " "dev %d, tag 0x%x, function 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, tag, function);
        }
    }
}

static inline void trace_usb_mtp_reset(int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_reset " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr);
        }
    }
}

static inline void trace_usb_mtp_command(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_COMMAND)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_command " "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x, 0x%x, 0x%x, 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, code, trans, arg0, arg1, arg2, arg3, arg4);
        }
    }
}

static inline void trace_usb_mtp_success(int dev, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_SUCCESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_success " "dev %d, trans 0x%x, args 0x%x, 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, trans, arg0, arg1);
        }
    }
}

static inline void trace_usb_mtp_error(int dev, uint16_t code, uint32_t trans, uint32_t arg0, uint32_t arg1)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_error " "dev %d, code 0x%x, trans 0x%x, args 0x%x, 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, code, trans, arg0, arg1);
        }
    }
}

static inline void trace_usb_mtp_data_in(int dev, uint32_t trans, uint32_t len)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_DATA_IN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_data_in " "dev %d, trans 0x%x, len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, trans, len);
        }
    }
}

static inline void trace_usb_mtp_xfer(int dev, uint32_t ep, uint32_t dlen, uint32_t plen)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_XFER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_xfer " "dev %d, ep %d, %d/%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ep, dlen, plen);
        }
    }
}

static inline void trace_usb_mtp_nak(int dev, uint32_t ep)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_NAK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_nak " "dev %d, ep %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, ep);
        }
    }
}

static inline void trace_usb_mtp_stall(int dev, const char * reason)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_STALL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_stall " "dev %d, reason: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, reason);
        }
    }
}

static inline void trace_usb_mtp_op_get_device_info(int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_DEVICE_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_device_info " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_usb_mtp_op_open_session(int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_OPEN_SESSION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_open_session " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_usb_mtp_op_close_session(int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_CLOSE_SESSION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_close_session " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_usb_mtp_op_get_storage_ids(int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_STORAGE_IDS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_storage_ids " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_usb_mtp_op_get_storage_info(int dev)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_STORAGE_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_storage_info " "dev %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev);
        }
    }
}

static inline void trace_usb_mtp_op_get_num_objects(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_NUM_OBJECTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_num_objects " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_op_get_object_handles(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT_HANDLES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_object_handles " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_op_get_object_info(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT_INFO)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_object_info " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_op_get_object(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_OBJECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_object " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_op_get_partial_object(int dev, uint32_t handle, const char * path, uint32_t offset, uint32_t length)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_GET_PARTIAL_OBJECT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_get_partial_object " "dev %d, handle 0x%x, path %s, off %d, len %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path, offset, length);
        }
    }
}

static inline void trace_usb_mtp_op_unknown(int dev, uint32_t code)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OP_UNKNOWN)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_op_unknown " "dev %d, command code 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, code);
        }
    }
}

static inline void trace_usb_mtp_object_alloc(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OBJECT_ALLOC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_object_alloc " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_object_free(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_OBJECT_FREE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_object_free " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_add_child(int dev, uint32_t handle, const char * path)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_ADD_CHILD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_add_child " "dev %d, handle 0x%x, path %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, handle, path);
        }
    }
}

static inline void trace_usb_mtp_inotify_event(int dev, const char * path, uint32_t mask, const char * s)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_MTP_INOTIFY_EVENT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_mtp_inotify_event " "dev %d, path %s mask 0x%x event %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, path, mask, s);
        }
    }
}

static inline void trace_usb_host_open_started(int bus, int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_OPEN_STARTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_open_started " "dev %d:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr);
        }
    }
}

static inline void trace_usb_host_open_success(int bus, int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_OPEN_SUCCESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_open_success " "dev %d:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr);
        }
    }
}

static inline void trace_usb_host_open_failure(int bus, int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_OPEN_FAILURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_open_failure " "dev %d:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr);
        }
    }
}

static inline void trace_usb_host_close(int bus, int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_CLOSE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_close " "dev %d:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr);
        }
    }
}

static inline void trace_usb_host_attach_kernel(int bus, int addr, int interface)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_ATTACH_KERNEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_attach_kernel " "dev %d:%d, if %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, interface);
        }
    }
}

static inline void trace_usb_host_detach_kernel(int bus, int addr, int interface)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_DETACH_KERNEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_detach_kernel " "dev %d:%d, if %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, interface);
        }
    }
}

static inline void trace_usb_host_set_address(int bus, int addr, int config)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_SET_ADDRESS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_set_address " "dev %d:%d, address %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, config);
        }
    }
}

static inline void trace_usb_host_set_config(int bus, int addr, int config)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_SET_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_set_config " "dev %d:%d, config %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, config);
        }
    }
}

static inline void trace_usb_host_set_interface(int bus, int addr, int interface, int alt)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_SET_INTERFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_set_interface " "dev %d:%d, interface %d, alt %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, interface, alt);
        }
    }
}

static inline void trace_usb_host_claim_interface(int bus, int addr, int config, int interface)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_CLAIM_INTERFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_claim_interface " "dev %d:%d, config %d, if %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, config, interface);
        }
    }
}

static inline void trace_usb_host_release_interface(int bus, int addr, int interface)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_RELEASE_INTERFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_release_interface " "dev %d:%d, if %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, interface);
        }
    }
}

static inline void trace_usb_host_req_control(int bus, int addr, void * p, int req, int value, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_REQ_CONTROL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_req_control " "dev %d:%d, packet %p, req 0x%x, value %d, index %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, p, req, value, index);
        }
    }
}

static inline void trace_usb_host_req_data(int bus, int addr, void * p, int in, int ep, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_REQ_DATA)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_req_data " "dev %d:%d, packet %p, in %d, ep %d, size %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, p, in, ep, size);
        }
    }
}

static inline void trace_usb_host_req_complete(int bus, int addr, void * p, int status, int length)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_REQ_COMPLETE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_req_complete " "dev %d:%d, packet %p, status %d, length %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, p, status, length);
        }
    }
}

static inline void trace_usb_host_req_emulated(int bus, int addr, void * p, int status)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_REQ_EMULATED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_req_emulated " "dev %d:%d, packet %p, status %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, p, status);
        }
    }
}

static inline void trace_usb_host_req_canceled(int bus, int addr, void * p)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_REQ_CANCELED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_req_canceled " "dev %d:%d, packet %p" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, p);
        }
    }
}

static inline void trace_usb_host_iso_start(int bus, int addr, int ep)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_ISO_START)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_iso_start " "dev %d:%d, ep %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, ep);
        }
    }
}

static inline void trace_usb_host_iso_stop(int bus, int addr, int ep)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_ISO_STOP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_iso_stop " "dev %d:%d, ep %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, ep);
        }
    }
}

static inline void trace_usb_host_iso_out_of_bufs(int bus, int addr, int ep)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_ISO_OUT_OF_BUFS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_iso_out_of_bufs " "dev %d:%d, ep %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, ep);
        }
    }
}

static inline void trace_usb_host_reset(int bus, int addr)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_reset " "dev %d:%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr);
        }
    }
}

static inline void trace_usb_host_auto_scan_enabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_auto_scan_enabled "  "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_host_auto_scan_disabled(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_DISABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_auto_scan_disabled "  "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_usb_host_parse_config(int bus, int addr, int value, int active)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_PARSE_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_parse_config " "dev %d:%d, value %d, active %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, value, active);
        }
    }
}

static inline void trace_usb_host_parse_interface(int bus, int addr, int num, int alt, int active)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_PARSE_INTERFACE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_parse_interface " "dev %d:%d, num %d, alt %d, active %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, num, alt, active);
        }
    }
}

static inline void trace_usb_host_parse_endpoint(int bus, int addr, int ep, const char * dir, const char * type, int active)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_PARSE_ENDPOINT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_parse_endpoint " "dev %d:%d, ep %d, %s, %s, active %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, ep, dir, type, active);
        }
    }
}

static inline void trace_usb_host_parse_error(int bus, int addr, const char * errmsg)
{
    if (true) {
        if (trace_event_get_state(TRACE_USB_HOST_PARSE_ERROR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:usb_host_parse_error " "dev %d:%d, msg %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , bus, addr, errmsg);
        }
    }
}
#endif /* TRACE_HW_USB_GENERATED_TRACERS_H */
