/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_VFIO_GENERATED_TRACERS_H
#define TRACE_HW_VFIO_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_VFIO_INTX_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_EOI_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_ENABLE_KVM_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_DISABLE_KVM_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_UPDATE_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_INTX_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_VECTOR_DO_USE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_VECTOR_RELEASE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_PBA_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_PBA_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_FIXUP_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_DISABLE_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_LOAD_ROM_EVENT;
extern TraceEvent _TRACE_VFIO_ROM_READ_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_SIZE_ROM_EVENT;
extern TraceEvent _TRACE_VFIO_VGA_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_VGA_READ_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_READ_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_WRITE_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_MSI_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_MSIX_EARLY_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_PCIE_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_PM_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_CHECK_AF_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_HOT_RESET_RESULT_EVENT;
extern TraceEvent _TRACE_VFIO_POPULATE_DEVICE_CONFIG_EVENT;
extern TraceEvent _TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_EVENT;
extern TraceEvent _TRACE_VFIO_REALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_ADD_EXT_CAP_DROPPED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_FLR_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_RESET_PM_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_VENDOR_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ROM_BLACKLISTED_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_3C3_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_3C3_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_RTL8168_PROBE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_EVENT;
extern TraceEvent _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_BAR4_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_BDSM_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_WRITE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_READ_EVENT;
extern TraceEvent _TRACE_VFIO_IOMMU_MAP_NOTIFY_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_ADD_RAM_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_DEL_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_LISTENER_REGION_DEL_EVENT;
extern TraceEvent _TRACE_VFIO_DISCONNECT_CONTAINER_EVENT;
extern TraceEvent _TRACE_VFIO_PUT_GROUP_EVENT;
extern TraceEvent _TRACE_VFIO_GET_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_PUT_BASE_DEVICE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SETUP_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAP_FAULT_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAP_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_EXIT_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_FINALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_MMAPS_SET_ENABLED_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_EVENT;
extern TraceEvent _TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_EVENT;
extern TraceEvent _TRACE_VFIO_GET_DEV_REGION_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_BASE_DEVICE_INIT_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_REALIZE_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_EOI_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_INTERRUPT_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_EVENT;
extern TraceEvent _TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_EVENT;
extern TraceEvent _TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_REGISTER_EVENT;
extern TraceEvent _TRACE_VFIO_PREREG_UNREGISTER_EVENT;
extern TraceEvent _TRACE_VFIO_SPAPR_CREATE_WINDOW_EVENT;
extern TraceEvent _TRACE_VFIO_SPAPR_REMOVE_WINDOW_EVENT;
extern uint16_t _TRACE_VFIO_INTX_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_EOI_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_ENABLE_KVM_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_DISABLE_KVM_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_UPDATE_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_INTX_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_VECTOR_DO_USE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_VECTOR_RELEASE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_PBA_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_PBA_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_FIXUP_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_DISABLE_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_LOAD_ROM_DSTATE;
extern uint16_t _TRACE_VFIO_ROM_READ_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_SIZE_ROM_DSTATE;
extern uint16_t _TRACE_VFIO_VGA_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_VGA_READ_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_READ_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_WRITE_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_MSI_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_MSIX_EARLY_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_PCIE_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_PM_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_CHECK_AF_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_HOT_RESET_RESULT_DSTATE;
extern uint16_t _TRACE_VFIO_POPULATE_DEVICE_CONFIG_DSTATE;
extern uint16_t _TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_DSTATE;
extern uint16_t _TRACE_VFIO_REALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_ADD_EXT_CAP_DROPPED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_FLR_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_RESET_PM_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_VENDOR_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ROM_BLACKLISTED_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_3C3_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_3C3_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_RTL8168_PROBE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_DSTATE;
extern uint16_t _TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_BAR4_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_BDSM_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_WRITE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_READ_DSTATE;
extern uint16_t _TRACE_VFIO_IOMMU_MAP_NOTIFY_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_ADD_RAM_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_DEL_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_LISTENER_REGION_DEL_DSTATE;
extern uint16_t _TRACE_VFIO_DISCONNECT_CONTAINER_DSTATE;
extern uint16_t _TRACE_VFIO_PUT_GROUP_DSTATE;
extern uint16_t _TRACE_VFIO_GET_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_PUT_BASE_DEVICE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SETUP_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAP_FAULT_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAP_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_EXIT_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_FINALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_MMAPS_SET_ENABLED_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_DSTATE;
extern uint16_t _TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_DSTATE;
extern uint16_t _TRACE_VFIO_GET_DEV_REGION_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_BASE_DEVICE_INIT_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_REALIZE_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_EOI_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_INTERRUPT_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_DSTATE;
extern uint16_t _TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_DSTATE;
extern uint16_t _TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_REGISTER_DSTATE;
extern uint16_t _TRACE_VFIO_PREREG_UNREGISTER_DSTATE;
extern uint16_t _TRACE_VFIO_SPAPR_CREATE_WINDOW_DSTATE;
extern uint16_t _TRACE_VFIO_SPAPR_REMOVE_WINDOW_DSTATE;
#define TRACE_VFIO_INTX_INTERRUPT_ENABLED 1
#define TRACE_VFIO_INTX_EOI_ENABLED 1
#define TRACE_VFIO_INTX_ENABLE_KVM_ENABLED 1
#define TRACE_VFIO_INTX_DISABLE_KVM_ENABLED 1
#define TRACE_VFIO_INTX_UPDATE_ENABLED 1
#define TRACE_VFIO_INTX_ENABLE_ENABLED 1
#define TRACE_VFIO_INTX_DISABLE_ENABLED 1
#define TRACE_VFIO_MSI_INTERRUPT_ENABLED 1
#define TRACE_VFIO_MSIX_VECTOR_DO_USE_ENABLED 1
#define TRACE_VFIO_MSIX_VECTOR_RELEASE_ENABLED 1
#define TRACE_VFIO_MSIX_ENABLE_ENABLED 1
#define TRACE_VFIO_MSIX_PBA_DISABLE_ENABLED 1
#define TRACE_VFIO_MSIX_PBA_ENABLE_ENABLED 1
#define TRACE_VFIO_MSIX_DISABLE_ENABLED 1
#define TRACE_VFIO_MSIX_FIXUP_ENABLED 1
#define TRACE_VFIO_MSI_ENABLE_ENABLED 1
#define TRACE_VFIO_MSI_DISABLE_ENABLED 1
#define TRACE_VFIO_PCI_LOAD_ROM_ENABLED 1
#define TRACE_VFIO_ROM_READ_ENABLED 1
#define TRACE_VFIO_PCI_SIZE_ROM_ENABLED 1
#define TRACE_VFIO_VGA_WRITE_ENABLED 1
#define TRACE_VFIO_VGA_READ_ENABLED 1
#define TRACE_VFIO_PCI_READ_CONFIG_ENABLED 1
#define TRACE_VFIO_PCI_WRITE_CONFIG_ENABLED 1
#define TRACE_VFIO_MSI_SETUP_ENABLED 1
#define TRACE_VFIO_MSIX_EARLY_SETUP_ENABLED 1
#define TRACE_VFIO_CHECK_PCIE_FLR_ENABLED 1
#define TRACE_VFIO_CHECK_PM_RESET_ENABLED 1
#define TRACE_VFIO_CHECK_AF_FLR_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES_ENABLED 1
#define TRACE_VFIO_PCI_HOT_RESET_RESULT_ENABLED 1
#define TRACE_VFIO_POPULATE_DEVICE_CONFIG_ENABLED 1
#define TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE_ENABLED 1
#define TRACE_VFIO_REALIZE_ENABLED 1
#define TRACE_VFIO_ADD_EXT_CAP_DROPPED_ENABLED 1
#define TRACE_VFIO_PCI_RESET_ENABLED 1
#define TRACE_VFIO_PCI_RESET_FLR_ENABLED 1
#define TRACE_VFIO_PCI_RESET_PM_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_VENDOR_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_DEVICE_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID_ENABLED 1
#define TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID_ENABLED 1
#define TRACE_VFIO_QUIRK_ROM_BLACKLISTED_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_3C3_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_3C3_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BAR4_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BAR2_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK_ENABLED 1
#define TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_MSIX_READ_ENABLED 1
#define TRACE_VFIO_QUIRK_RTL8168_PROBE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE_ENABLED 1
#define TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_ENABLED 1
#define TRACE_VFIO_PCI_IGD_BAR4_WRITE_ENABLED 1
#define TRACE_VFIO_PCI_IGD_BDSM_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_OPREGION_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED_ENABLED 1
#define TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED_ENABLED 1
#define TRACE_VFIO_REGION_WRITE_ENABLED 1
#define TRACE_VFIO_REGION_READ_ENABLED 1
#define TRACE_VFIO_IOMMU_MAP_NOTIFY_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_SKIP_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_IOMMU_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_ADD_RAM_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_DEL_SKIP_ENABLED 1
#define TRACE_VFIO_LISTENER_REGION_DEL_ENABLED 1
#define TRACE_VFIO_DISCONNECT_CONTAINER_ENABLED 1
#define TRACE_VFIO_PUT_GROUP_ENABLED 1
#define TRACE_VFIO_GET_DEVICE_ENABLED 1
#define TRACE_VFIO_PUT_BASE_DEVICE_ENABLED 1
#define TRACE_VFIO_REGION_SETUP_ENABLED 1
#define TRACE_VFIO_REGION_MMAP_FAULT_ENABLED 1
#define TRACE_VFIO_REGION_MMAP_ENABLED 1
#define TRACE_VFIO_REGION_EXIT_ENABLED 1
#define TRACE_VFIO_REGION_FINALIZE_ENABLED 1
#define TRACE_VFIO_REGION_MMAPS_SET_ENABLED_ENABLED 1
#define TRACE_VFIO_REGION_SPARSE_MMAP_HEADER_ENABLED 1
#define TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY_ENABLED 1
#define TRACE_VFIO_GET_DEV_REGION_ENABLED 1
#define TRACE_VFIO_PLATFORM_BASE_DEVICE_INIT_ENABLED 1
#define TRACE_VFIO_PLATFORM_REALIZE_ENABLED 1
#define TRACE_VFIO_PLATFORM_EOI_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_INTERRUPT_ENABLED 1
#define TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD_ENABLED 1
#define TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS_ENABLED 1
#define TRACE_VFIO_INTP_INTERRUPT_SET_PENDING_ENABLED 1
#define TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION_ENABLED 1
#define TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION_ENABLED 1
#define TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP_ENABLED 1
#define TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP_ENABLED 1
#define TRACE_VFIO_PREREG_REGISTER_ENABLED 1
#define TRACE_VFIO_PREREG_UNREGISTER_ENABLED 1
#define TRACE_VFIO_SPAPR_CREATE_WINDOW_ENABLED 1
#define TRACE_VFIO_SPAPR_REMOVE_WINDOW_ENABLED 1
#include "qemu/log.h"


static inline void trace_vfio_intx_interrupt(const char * name, char line)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_INTERRUPT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_interrupt " " (%s) Pin %c" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, line);
        }
    }
}

static inline void trace_vfio_intx_eoi(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_EOI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_eoi " " (%s) EOI" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_intx_enable_kvm(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_ENABLE_KVM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_enable_kvm " " (%s) KVM INTx accel enabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_intx_disable_kvm(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_DISABLE_KVM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_disable_kvm " " (%s) KVM INTx accel disabled" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_intx_update(const char * name, int new_irq, int target_irq)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_UPDATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_update " " (%s) IRQ moved %d -> %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, new_irq, target_irq);
        }
    }
}

static inline void trace_vfio_intx_enable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_enable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_intx_disable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTX_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intx_disable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_msi_interrupt(const char * name, int index, uint64_t addr, int data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSI_INTERRUPT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msi_interrupt " " (%s) vector %d 0x%"PRIx64"/0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, addr, data);
        }
    }
}

static inline void trace_vfio_msix_vector_do_use(const char * name, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_VECTOR_DO_USE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_vector_do_use " " (%s) vector %d used" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index);
        }
    }
}

static inline void trace_vfio_msix_vector_release(const char * name, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_VECTOR_RELEASE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_vector_release " " (%s) vector %d released" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index);
        }
    }
}

static inline void trace_vfio_msix_enable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_enable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_msix_pba_disable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_PBA_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_pba_disable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_msix_pba_enable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_PBA_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_pba_enable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_msix_disable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_disable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_msix_fixup(const char * name, int bar, uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_FIXUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_fixup " " (%s) MSI-X region %d mmap fixup [0x%"PRIx64" - 0x%"PRIx64"]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, bar, start, end);
        }
    }
}

static inline void trace_vfio_msi_enable(const char * name, int nr_vectors)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSI_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msi_enable " " (%s) Enabled %d MSI vectors" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, nr_vectors);
        }
    }
}

static inline void trace_vfio_msi_disable(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSI_DISABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msi_disable " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_load_rom(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_LOAD_ROM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_load_rom " "Device %s ROM:\n  size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, size, offset, flags);
        }
    }
}

static inline void trace_vfio_rom_read(const char * name, uint64_t addr, int size, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_ROM_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_rom_read " " (%s, 0x%"PRIx64", 0x%x) = 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, addr, size, data);
        }
    }
}

static inline void trace_vfio_pci_size_rom(const char * name, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_SIZE_ROM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_size_rom " "%s ROM size 0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, size);
        }
    }
}

static inline void trace_vfio_vga_write(uint64_t addr, uint64_t data, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_VGA_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_vga_write " " (0x%"PRIx64", 0x%"PRIx64", %d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, data, size);
        }
    }
}

static inline void trace_vfio_vga_read(uint64_t addr, int size, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_VGA_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_vga_read " " (0x%"PRIx64", %d) = 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , addr, size, data);
        }
    }
}

static inline void trace_vfio_pci_read_config(const char * name, int addr, int len, int val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_READ_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_read_config " " (%s, @0x%x, len=0x%x) %x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, addr, len, val);
        }
    }
}

static inline void trace_vfio_pci_write_config(const char * name, int addr, int val, int len)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_WRITE_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_write_config " " (%s, @0x%x, 0x%x, len=0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, addr, val, len);
        }
    }
}

static inline void trace_vfio_msi_setup(const char * name, int pos)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSI_SETUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msi_setup " "%s PCI MSI CAP @0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, pos);
        }
    }
}

static inline void trace_vfio_msix_early_setup(const char * name, int pos, int table_bar, int offset, int entries)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_MSIX_EARLY_SETUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_msix_early_setup " "%s PCI MSI-X CAP @0x%x, BAR %d, offset 0x%x, entries %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, pos, table_bar, offset, entries);
        }
    }
}

static inline void trace_vfio_check_pcie_flr(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_CHECK_PCIE_FLR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_check_pcie_flr " "%s Supports FLR via PCIe cap" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_check_pm_reset(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_CHECK_PM_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_check_pm_reset " "%s Supports PM reset" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_check_af_flr(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_CHECK_AF_FLR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_check_af_flr " "%s Supports FLR via AF cap" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_hot_reset(const char * name, const char * type)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_hot_reset " " (%s) %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, type);
        }
    }
}

static inline void trace_vfio_pci_hot_reset_has_dep_devices(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_HAS_DEP_DEVICES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_hot_reset_has_dep_devices " "%s: hot reset dependent devices:" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_hot_reset_dep_devices(int domain, int bus, int slot, int function, int group_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_DEP_DEVICES)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_hot_reset_dep_devices " "\t%04x:%02x:%02x.%x group %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , domain, bus, slot, function, group_id);
        }
    }
}

static inline void trace_vfio_pci_hot_reset_result(const char * name, const char * result)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_HOT_RESET_RESULT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_hot_reset_result " "%s hot reset: %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, result);
        }
    }
}

static inline void trace_vfio_populate_device_config(const char * name, unsigned long size, unsigned long offset, unsigned long flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_POPULATE_DEVICE_CONFIG)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_populate_device_config " "Device %s config:\n  size: 0x%lx, offset: 0x%lx, flags: 0x%lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, size, offset, flags);
        }
    }
}

static inline void trace_vfio_populate_device_get_irq_info_failure(void)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_POPULATE_DEVICE_GET_IRQ_INFO_FAILURE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_populate_device_get_irq_info_failure " "VFIO_DEVICE_GET_IRQ_INFO failure: %m" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          );
        }
    }
}

static inline void trace_vfio_realize(const char * name, int group_id)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_realize " " (%s) group %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, group_id);
        }
    }
}

static inline void trace_vfio_add_ext_cap_dropped(const char * name, uint16_t cap, uint16_t offset)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_ADD_EXT_CAP_DROPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_add_ext_cap_dropped " "%s %x@%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, cap, offset);
        }
    }
}

static inline void trace_vfio_pci_reset(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_reset " " (%s)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_reset_flr(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_RESET_FLR)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_reset_flr " "%s FLR/VFIO_DEVICE_RESET" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_reset_pm(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_RESET_PM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_reset_pm " "%s PCI PM Reset" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_emulated_vendor_id(const char * name, uint16_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_VENDOR_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_emulated_vendor_id " "%s %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, val);
        }
    }
}

static inline void trace_vfio_pci_emulated_device_id(const char * name, uint16_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_DEVICE_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_emulated_device_id " "%s %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, val);
        }
    }
}

static inline void trace_vfio_pci_emulated_sub_vendor_id(const char * name, uint16_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_SUB_VENDOR_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_emulated_sub_vendor_id " "%s %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, val);
        }
    }
}

static inline void trace_vfio_pci_emulated_sub_device_id(const char * name, uint16_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_EMULATED_SUB_DEVICE_ID)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_emulated_sub_device_id " "%s %04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, val);
        }
    }
}

static inline void trace_vfio_quirk_rom_blacklisted(const char * name, uint16_t vid, uint16_t did)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ROM_BLACKLISTED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_rom_blacklisted " "%s %04x:%04x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, vid, did);
        }
    }
}

static inline void trace_vfio_quirk_generic_window_address_write(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_ADDRESS_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_generic_window_address_write " "%s %s 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, region_name, data);
        }
    }
}

static inline void trace_vfio_quirk_generic_window_data_read(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_generic_window_data_read " "%s %s 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, region_name, data);
        }
    }
}

static inline void trace_vfio_quirk_generic_window_data_write(const char * name, const char * region_name, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_WINDOW_DATA_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_generic_window_data_write " "%s %s 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, region_name, data);
        }
    }
}

static inline void trace_vfio_quirk_generic_mirror_read(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_MIRROR_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_generic_mirror_read " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, region_name, addr, data);
        }
    }
}

static inline void trace_vfio_quirk_generic_mirror_write(const char * name, const char * region_name, uint64_t addr, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_GENERIC_MIRROR_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_generic_mirror_write " "%s %s 0x%"PRIx64": 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, region_name, addr, data);
        }
    }
}

static inline void trace_vfio_quirk_ati_3c3_read(const char * name, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_3C3_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_3c3_read " "%s 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, data);
        }
    }
}

static inline void trace_vfio_quirk_ati_3c3_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_3C3_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_3c3_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bar4_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BAR4_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bar4_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bar2_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BAR2_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bar2_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_state(const char * name, const char * state)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_3d0_state " "%s %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, state);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_read(const char * name, uint8_t offset, unsigned size, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_3d0_read " " (%s, @0x%x, len=0x%x) %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, offset, size, val);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_write(const char * name, uint8_t offset, uint64_t data, unsigned size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_3d0_write " "(%s, @0x%x, 0x%"PRIx64", len=0x%x)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, offset, data, size);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_3d0_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_3D0_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_3d0_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar5_state(const char * name, const char * state)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR5_STATE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_bar5_state " "%s %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, state);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar5_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR5_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_bar5_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar0_msi_ack(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR0_MSI_ACK)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_bar0_msi_ack " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_nvidia_bar0_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_NVIDIA_BAR0_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_nvidia_bar0_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_fake_latch(const char * name, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_FAKE_LATCH)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_rtl8168_fake_latch " "%s 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, val);
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_msix_write(const char * name, uint16_t offset, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_MSIX_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_rtl8168_msix_write " "%s MSI-X table write[0x%x]: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, offset, val);
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_msix_read(const char * name, uint16_t offset, uint64_t val)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_MSIX_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_rtl8168_msix_read " "%s MSI-X table read[0x%x]: 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, offset, val);
        }
    }
}

static inline void trace_vfio_quirk_rtl8168_probe(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_RTL8168_PROBE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_rtl8168_probe " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_skipped(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_SKIPPED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bonaire_reset_skipped " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_no_smc(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_NO_SMC)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bonaire_reset_no_smc " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_timeout(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_TIMEOUT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bonaire_reset_timeout " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset_done(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET_DONE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bonaire_reset_done " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_quirk_ati_bonaire_reset(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_QUIRK_ATI_BONAIRE_RESET)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_quirk_ati_bonaire_reset " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_igd_bar4_write(const char * name, uint32_t index, uint32_t data, uint32_t base)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_IGD_BAR4_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_igd_bar4_write " "%s [%03x] %08x -> %08x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, data, base);
        }
    }
}

static inline void trace_vfio_pci_igd_bdsm_enabled(const char * name, int size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_IGD_BDSM_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_igd_bdsm_enabled " "%s %dMB" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, size);
        }
    }
}

static inline void trace_vfio_pci_igd_opregion_enabled(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_IGD_OPREGION_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_igd_opregion_enabled " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_igd_host_bridge_enabled(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_IGD_HOST_BRIDGE_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_igd_host_bridge_enabled " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_pci_igd_lpc_bridge_enabled(const char * name)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PCI_IGD_LPC_BRIDGE_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_pci_igd_lpc_bridge_enabled " "%s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name);
        }
    }
}

static inline void trace_vfio_region_write(const char * name, int index, uint64_t addr, uint64_t data, unsigned size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_WRITE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_write " " (%s:region%d+0x%"PRIx64", 0x%"PRIx64 ", %d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, addr, data, size);
        }
    }
}

static inline void trace_vfio_region_read(char * name, int index, uint64_t addr, unsigned size, uint64_t data)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_READ)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_read " " (%s:region%d+0x%"PRIx64", %d) = 0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, addr, size, data);
        }
    }
}

static inline void trace_vfio_iommu_map_notify(const char * op, uint64_t iova_start, uint64_t iova_end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_IOMMU_MAP_NOTIFY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_iommu_map_notify " "iommu %s @ %"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , op, iova_start, iova_end);
        }
    }
}

static inline void trace_vfio_listener_region_add_skip(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_SKIP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_listener_region_add_skip " "SKIPPING region_add %"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_listener_region_add_iommu(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_IOMMU)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_listener_region_add_iommu " "region_add [iommu] %"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_listener_region_add_ram(uint64_t iova_start, uint64_t iova_end, void * vaddr)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_ADD_RAM)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_listener_region_add_ram " "region_add [ram] %"PRIx64" - %"PRIx64" [%p]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , iova_start, iova_end, vaddr);
        }
    }
}

static inline void trace_vfio_listener_region_del_skip(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_DEL_SKIP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_listener_region_del_skip " "SKIPPING region_del %"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_listener_region_del(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_LISTENER_REGION_DEL)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_listener_region_del " "region_del %"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_disconnect_container(int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_DISCONNECT_CONTAINER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_disconnect_container " "close container->fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , fd);
        }
    }
}

static inline void trace_vfio_put_group(int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PUT_GROUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_put_group " "close group->fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , fd);
        }
    }
}

static inline void trace_vfio_get_device(const char * name, unsigned int flags, unsigned int num_regions, unsigned int num_irqs)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_GET_DEVICE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_get_device " "Device %s flags: %u, regions: %u, irqs: %u" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, flags, num_regions, num_irqs);
        }
    }
}

static inline void trace_vfio_put_base_device(int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PUT_BASE_DEVICE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_put_base_device " "close vdev->fd=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , fd);
        }
    }
}

static inline void trace_vfio_region_setup(const char * dev, int index, const char * name, unsigned long flags, unsigned long offset, unsigned long size)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_SETUP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_setup " "Device %s, region %d \"%s\", flags: %lx, offset: %lx, size: %lx" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , dev, index, name, flags, offset, size);
        }
    }
}

static inline void trace_vfio_region_mmap_fault(const char * name, int index, unsigned long offset, unsigned long size, int fault)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_MMAP_FAULT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_mmap_fault " "Region %s mmaps[%d], [%lx - %lx], fault: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, offset, size, fault);
        }
    }
}

static inline void trace_vfio_region_mmap(const char * name, unsigned long offset, unsigned long end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_MMAP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_mmap " "Region %s [%lx - %lx]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, offset, end);
        }
    }
}

static inline void trace_vfio_region_exit(const char * name, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_EXIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_exit " "Device %s, region %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index);
        }
    }
}

static inline void trace_vfio_region_finalize(const char * name, int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_FINALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_finalize " "Device %s, region %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index);
        }
    }
}

static inline void trace_vfio_region_mmaps_set_enabled(const char * name, bool enabled)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_MMAPS_SET_ENABLED)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_mmaps_set_enabled " "Region %s mmaps enabled: %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, enabled);
        }
    }
}

static inline void trace_vfio_region_sparse_mmap_header(const char * name, int index, int nr_areas)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_SPARSE_MMAP_HEADER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_sparse_mmap_header " "Device %s region %d: %d sparse mmap entries" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, nr_areas);
        }
    }
}

static inline void trace_vfio_region_sparse_mmap_entry(int i, unsigned long start, unsigned long end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_REGION_SPARSE_MMAP_ENTRY)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_region_sparse_mmap_entry " "sparse entry %d [0x%lx - 0x%lx]" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , i, start, end);
        }
    }
}

static inline void trace_vfio_get_dev_region(const char * name, int index, uint32_t type, uint32_t subtype)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_GET_DEV_REGION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_get_dev_region " "%s index %d, %08x/%0x8" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, index, type, subtype);
        }
    }
}

static inline void trace_vfio_platform_base_device_init(char * name, int groupid)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_BASE_DEVICE_INIT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_base_device_init " "%s belongs to group #%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, groupid);
        }
    }
}

static inline void trace_vfio_platform_realize(char * name, char * compat)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_REALIZE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_realize " "vfio device %s, compat = %s" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , name, compat);
        }
    }
}

static inline void trace_vfio_platform_eoi(int pin, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_EOI)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_eoi " "EOI IRQ pin %d (fd=%d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pin, fd);
        }
    }
}

static inline void trace_vfio_platform_intp_mmap_enable(int pin)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_MMAP_ENABLE)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_intp_mmap_enable " "IRQ #%d still active, stay in slow path" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pin);
        }
    }
}

static inline void trace_vfio_platform_intp_interrupt(int pin, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_INTERRUPT)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_intp_interrupt " "Inject IRQ #%d (fd = %d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pin, fd);
        }
    }
}

static inline void trace_vfio_platform_intp_inject_pending_lockheld(int pin, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_INTP_INJECT_PENDING_LOCKHELD)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_intp_inject_pending_lockheld " "Inject pending IRQ #%d (fd = %d)" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pin, fd);
        }
    }
}

static inline void trace_vfio_platform_populate_interrupts(int pin, int count, int flags)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_POPULATE_INTERRUPTS)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_populate_interrupts " "- IRQ index %d: count %d, flags=0x%x" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , pin, count, flags);
        }
    }
}

static inline void trace_vfio_intp_interrupt_set_pending(int index)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_INTP_INTERRUPT_SET_PENDING)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_intp_interrupt_set_pending " "irq %d is set PENDING" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index);
        }
    }
}

static inline void trace_vfio_platform_start_level_irqfd_injection(int index, int fd, int resamplefd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_START_LEVEL_IRQFD_INJECTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_start_level_irqfd_injection " "IRQ index=%d, fd = %d, resamplefd = %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, fd, resamplefd);
        }
    }
}

static inline void trace_vfio_platform_start_edge_irqfd_injection(int index, int fd)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PLATFORM_START_EDGE_IRQFD_INJECTION)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_platform_start_edge_irqfd_injection " "IRQ index=%d, fd = %d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , index, fd);
        }
    }
}

static inline void trace_vfio_prereg_listener_region_add_skip(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PREREG_LISTENER_REGION_ADD_SKIP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_prereg_listener_region_add_skip " "%"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_prereg_listener_region_del_skip(uint64_t start, uint64_t end)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PREREG_LISTENER_REGION_DEL_SKIP)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_prereg_listener_region_del_skip " "%"PRIx64" - %"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , start, end);
        }
    }
}

static inline void trace_vfio_prereg_register(uint64_t va, uint64_t size, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PREREG_REGISTER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_prereg_register " "va=%"PRIx64" size=%"PRIx64" ret=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , va, size, ret);
        }
    }
}

static inline void trace_vfio_prereg_unregister(uint64_t va, uint64_t size, int ret)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_PREREG_UNREGISTER)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_prereg_unregister " "va=%"PRIx64" size=%"PRIx64" ret=%d" "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , va, size, ret);
        }
    }
}

static inline void trace_vfio_spapr_create_window(int ps, uint64_t ws, uint64_t off)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_SPAPR_CREATE_WINDOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_spapr_create_window " "pageshift=0x%x winsize=0x%"PRIx64" offset=0x%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , ps, ws, off);
        }
    }
}

static inline void trace_vfio_spapr_remove_window(uint64_t off)
{
    if (true) {
        if (trace_event_get_state(TRACE_VFIO_SPAPR_REMOVE_WINDOW)) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
            qemu_log_mask(LOG_TRACE, "%d@%zd.%06zd:vfio_spapr_remove_window " "offset=%"PRIx64 "\n",
                          getpid(),
                          (size_t)_now.tv_sec, (size_t)_now.tv_usec
                          , off);
        }
    }
}
#endif /* TRACE_HW_VFIO_GENERATED_TRACERS_H */
